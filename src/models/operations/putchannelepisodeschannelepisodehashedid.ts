/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The status of whether or not the episode has been published to your channel.
 */
export const PutChannelEpisodesChannelEpisodeHashedIdPublishStatus = {
  Draft: "draft",
  Published: "published",
  Scheduled: "scheduled",
} as const;
/**
 * The status of whether or not the episode has been published to your channel.
 */
export type PutChannelEpisodesChannelEpisodeHashedIdPublishStatus = ClosedEnum<
  typeof PutChannelEpisodesChannelEpisodeHashedIdPublishStatus
>;

/**
 * The type of episode. This parameter only takes effect if podcasting is enabled for the channel.
 */
export const PutChannelEpisodesChannelEpisodeHashedIdEpisodeType = {
  Full: "full",
  Trailer: "trailer",
  Bonus: "bonus",
} as const;
/**
 * The type of episode. This parameter only takes effect if podcasting is enabled for the channel.
 */
export type PutChannelEpisodesChannelEpisodeHashedIdEpisodeType = ClosedEnum<
  typeof PutChannelEpisodesChannelEpisodeHashedIdEpisodeType
>;

export type PutChannelEpisodesChannelEpisodeHashedIdRequestBody = {
  /**
   * The episode's description or episode notes.
   */
  description?: string | null | undefined;
  /**
   * The episode's title. If not provided, the channel episode uses the title of the media used to create it.
   */
  title?: string | null | undefined;
  /**
   * The unique alphanumeric identifier for the media associated with this channel episode.
   */
  mediaHashedId?: string | undefined;
  /**
   * The unique alphanumeric identifier for the live stream event associated with this channel episode.
   */
  liveStreamEventHashedId?: string | undefined;
  /**
   * A short summary of the episode that is displayed when space is limited.
   */
  summary?: string | null | undefined;
  /**
   * The status of whether or not the episode has been published to your channel.
   */
  publishStatus?:
    | PutChannelEpisodesChannelEpisodeHashedIdPublishStatus
    | undefined;
  /**
   * The date and time when the episode is scheduled to be published in UTC timezone.
   */
  publishAt?: Date | undefined;
  /**
   * Additional notes for the episode.
   */
  episodeNotes?: string | undefined;
  /**
   * The type of episode. This parameter only takes effect if podcasting is enabled for the channel.
   */
  episodeType?: PutChannelEpisodesChannelEpisodeHashedIdEpisodeType | undefined;
  /**
   * The number of the episode. This parameter only takes effect if podcasting is enabled for the channel.
   */
  episodeNumber?: number | undefined;
  /**
   * The season number of the episode. This parameter only takes effect if podcasting is enabled for the channel.
   */
  seasonNumber?: number | undefined;
  /**
   * Whether the episode contains explicit content. This parameter only takes effect if podcasting is enabled for the channel.
   */
  explicitContent?: boolean | undefined;
  /**
   * Whether to hide the episode from the podcast feed. This parameter only takes effect if podcasting is enabled for the channel.
   */
  hideFromFeed?: boolean | undefined;
};

export type PutChannelEpisodesChannelEpisodeHashedIdRequest = {
  /**
   * The hashed id of the Channel Episode
   */
  channelEpisodeHashedId: string;
  requestBody?: PutChannelEpisodesChannelEpisodeHashedIdRequestBody | undefined;
};

/**
 * A channel episode represents a media that has been added to a channel. Only published
 *
 * @remarks
 * episodes are displayed in a channel.
 */
export type PutChannelEpisodesChannelEpisodeHashedIdResponse = {
  /**
   * A unique alphanumeric identifier for the channel episode's channel.
   */
  channelHashedId: string;
  /**
   * The date when the channel episode was originally created.
   */
  created: Date;
  /**
   * A cursor for stable pagination based on current `sort_by` order. You can pass this to `cursor[before]` or `cursor[after]` as a parameter to fetch the records before or after this record in the same sort order. This is only populated if records were fetched with `cursor[enabled]`, or `cursor[before]` or `cursor[after]`.
   */
  cursor?: string | null | undefined;
  /**
   * The channel episode's description or episode notes.
   */
  description: string;
  /**
   * A short summary of the episode that is displayed when space is limited.
   */
  summary: string;
  /**
   * A unique alphanumeric identifier for the channel episode.
   */
  hashedId: string;
  /**
   * A unique alphanumeric identifier for the channel episode's media.
   */
  mediaHashedId: string;
  /**
   * Whether the channel episode has been published or is still in draft form.
   */
  published: boolean;
  /**
   * The date and time when the episode is scheduled to be published in UTC timezone (only present when publish_status is 'scheduled').
   */
  publishAt?: Date | undefined;
  /**
   * The title of the channel episode
   */
  title: string | null;
  /**
   * The date when the channel was last updated.
   */
  updated: Date;
};

/** @internal */
export const PutChannelEpisodesChannelEpisodeHashedIdPublishStatus$outboundSchema:
  z.ZodNativeEnum<
    typeof PutChannelEpisodesChannelEpisodeHashedIdPublishStatus
  > = z.nativeEnum(PutChannelEpisodesChannelEpisodeHashedIdPublishStatus);

/** @internal */
export const PutChannelEpisodesChannelEpisodeHashedIdEpisodeType$outboundSchema:
  z.ZodNativeEnum<typeof PutChannelEpisodesChannelEpisodeHashedIdEpisodeType> =
    z.nativeEnum(PutChannelEpisodesChannelEpisodeHashedIdEpisodeType);

/** @internal */
export type PutChannelEpisodesChannelEpisodeHashedIdRequestBody$Outbound = {
  description?: string | null | undefined;
  title?: string | null | undefined;
  media_hashed_id?: string | undefined;
  live_stream_event_hashed_id?: string | undefined;
  summary?: string | null | undefined;
  publish_status?: string | undefined;
  publish_at?: string | undefined;
  episode_notes?: string | undefined;
  episode_type?: string | undefined;
  episode_number?: number | undefined;
  season_number?: number | undefined;
  explicit_content?: boolean | undefined;
  hide_from_feed?: boolean | undefined;
};

/** @internal */
export const PutChannelEpisodesChannelEpisodeHashedIdRequestBody$outboundSchema:
  z.ZodType<
    PutChannelEpisodesChannelEpisodeHashedIdRequestBody$Outbound,
    z.ZodTypeDef,
    PutChannelEpisodesChannelEpisodeHashedIdRequestBody
  > = z.object({
    description: z.nullable(z.string()).optional(),
    title: z.nullable(z.string()).optional(),
    mediaHashedId: z.string().optional(),
    liveStreamEventHashedId: z.string().optional(),
    summary: z.nullable(z.string()).optional(),
    publishStatus:
      PutChannelEpisodesChannelEpisodeHashedIdPublishStatus$outboundSchema
        .optional(),
    publishAt: z.date().transform(v => v.toISOString()).optional(),
    episodeNotes: z.string().optional(),
    episodeType:
      PutChannelEpisodesChannelEpisodeHashedIdEpisodeType$outboundSchema
        .optional(),
    episodeNumber: z.number().int().optional(),
    seasonNumber: z.number().int().optional(),
    explicitContent: z.boolean().optional(),
    hideFromFeed: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      mediaHashedId: "media_hashed_id",
      liveStreamEventHashedId: "live_stream_event_hashed_id",
      publishStatus: "publish_status",
      publishAt: "publish_at",
      episodeNotes: "episode_notes",
      episodeType: "episode_type",
      episodeNumber: "episode_number",
      seasonNumber: "season_number",
      explicitContent: "explicit_content",
      hideFromFeed: "hide_from_feed",
    });
  });

export function putChannelEpisodesChannelEpisodeHashedIdRequestBodyToJSON(
  putChannelEpisodesChannelEpisodeHashedIdRequestBody:
    PutChannelEpisodesChannelEpisodeHashedIdRequestBody,
): string {
  return JSON.stringify(
    PutChannelEpisodesChannelEpisodeHashedIdRequestBody$outboundSchema.parse(
      putChannelEpisodesChannelEpisodeHashedIdRequestBody,
    ),
  );
}

/** @internal */
export type PutChannelEpisodesChannelEpisodeHashedIdRequest$Outbound = {
  channelEpisodeHashedId: string;
  RequestBody?:
    | PutChannelEpisodesChannelEpisodeHashedIdRequestBody$Outbound
    | undefined;
};

/** @internal */
export const PutChannelEpisodesChannelEpisodeHashedIdRequest$outboundSchema:
  z.ZodType<
    PutChannelEpisodesChannelEpisodeHashedIdRequest$Outbound,
    z.ZodTypeDef,
    PutChannelEpisodesChannelEpisodeHashedIdRequest
  > = z.object({
    channelEpisodeHashedId: z.string(),
    requestBody: z.lazy(() =>
      PutChannelEpisodesChannelEpisodeHashedIdRequestBody$outboundSchema
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      requestBody: "RequestBody",
    });
  });

export function putChannelEpisodesChannelEpisodeHashedIdRequestToJSON(
  putChannelEpisodesChannelEpisodeHashedIdRequest:
    PutChannelEpisodesChannelEpisodeHashedIdRequest,
): string {
  return JSON.stringify(
    PutChannelEpisodesChannelEpisodeHashedIdRequest$outboundSchema.parse(
      putChannelEpisodesChannelEpisodeHashedIdRequest,
    ),
  );
}

/** @internal */
export const PutChannelEpisodesChannelEpisodeHashedIdResponse$inboundSchema:
  z.ZodType<
    PutChannelEpisodesChannelEpisodeHashedIdResponse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    channel_hashed_id: z.string(),
    created: z.string().datetime({ offset: true }).transform(v => new Date(v)),
    cursor: z.nullable(z.string()).optional(),
    description: z.string(),
    summary: z.string(),
    hashed_id: z.string(),
    media_hashed_id: z.string(),
    published: z.boolean(),
    publish_at: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ).optional(),
    title: z.nullable(z.string()),
    updated: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  }).transform((v) => {
    return remap$(v, {
      "channel_hashed_id": "channelHashedId",
      "hashed_id": "hashedId",
      "media_hashed_id": "mediaHashedId",
      "publish_at": "publishAt",
    });
  });

export function putChannelEpisodesChannelEpisodeHashedIdResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  PutChannelEpisodesChannelEpisodeHashedIdResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PutChannelEpisodesChannelEpisodeHashedIdResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PutChannelEpisodesChannelEpisodeHashedIdResponse' from JSON`,
  );
}
