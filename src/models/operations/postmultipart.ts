/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { blobLikeSchema } from "../../types/blobs.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

export const PostMultipartServerList = [
  "https://upload.wistia.com",
] as const;

export type FileT = {
  fileName: string;
  content: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

export type PostMultipartRequest = {
  /**
   * The hashed id of the project to upload media into.
   */
  projectId?: string | undefined;
  /**
   * A display name to use for the media in Wistia.
   */
  name?: string | undefined;
  /**
   * A description to use for the media in Wistia.
   */
  description?: string | undefined;
  /**
   * A Wistia contact id.
   */
  contactId?: number | undefined;
  /**
   * A 64 character hex string. This parameter can be found on your API access page OR can be the token you received from authenticating via Oauth2. Note this approach is legacy and discouraged. We recommend using Bearer Token authentication.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  accessToken?: string | undefined;
  /**
   * The media file, multipart-form encoded into the request body.
   */
  file: FileT | Blob;
};

export type PostMultipartError = {
  code?: string | undefined;
  detail?: string | undefined;
};

/**
 * Response after successfully uploading or importing media
 */
export type PostMultipartResponse = {
  /**
   * A unique numeric identifier for the media within the system.
   */
  id?: number | undefined;
  /**
   * The display name of the media.
   */
  name?: string | undefined;
  /**
   * A string representing what type of media this is.
   */
  type?: string | undefined;
  /**
   * The date when the media was originally uploaded.
   */
  created?: Date | undefined;
  /**
   * The date when the media was last changed.
   */
  updated?: Date | undefined;
  /**
   * Specifies the length (in seconds) for audio and video files.
   */
  duration?: number | undefined;
  /**
   * A unique alphanumeric identifier for this media.
   */
  hashedId?: string | undefined;
  /**
   * A floating point value between 0 and 1 that indicates the progress of the processing for this file.
   */
  progress?: number | undefined;
  thumbnail?: models.Thumbnail | undefined;
};

/** @internal */
export const FileT$inboundSchema: z.ZodType<FileT, z.ZodTypeDef, unknown> = z
  .object({
    fileName: z.string(),
    content: z.union([
      z.instanceof(ReadableStream<Uint8Array>),
      z.instanceof(Blob),
      z.instanceof(ArrayBuffer),
      z.instanceof(Uint8Array),
    ]),
  });

/** @internal */
export type FileT$Outbound = {
  fileName: string;
  content: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

/** @internal */
export const FileT$outboundSchema: z.ZodType<
  FileT$Outbound,
  z.ZodTypeDef,
  FileT
> = z.object({
  fileName: z.string(),
  content: z.union([
    z.instanceof(ReadableStream<Uint8Array>),
    z.instanceof(Blob),
    z.instanceof(ArrayBuffer),
    z.instanceof(Uint8Array),
  ]),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FileT$ {
  /** @deprecated use `FileT$inboundSchema` instead. */
  export const inboundSchema = FileT$inboundSchema;
  /** @deprecated use `FileT$outboundSchema` instead. */
  export const outboundSchema = FileT$outboundSchema;
  /** @deprecated use `FileT$Outbound` instead. */
  export type Outbound = FileT$Outbound;
}

export function fileToJSON(fileT: FileT): string {
  return JSON.stringify(FileT$outboundSchema.parse(fileT));
}

export function fileFromJSON(
  jsonString: string,
): SafeParseResult<FileT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FileT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FileT' from JSON`,
  );
}

/** @internal */
export const PostMultipartRequest$inboundSchema: z.ZodType<
  PostMultipartRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  project_id: z.string().optional(),
  name: z.string().optional(),
  description: z.string().optional(),
  contact_id: z.number().int().optional(),
  access_token: z.string().optional(),
  file: z.lazy(() => FileT$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "project_id": "projectId",
    "contact_id": "contactId",
    "access_token": "accessToken",
  });
});

/** @internal */
export type PostMultipartRequest$Outbound = {
  project_id?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  contact_id?: number | undefined;
  access_token?: string | undefined;
  file: FileT$Outbound | Blob;
};

/** @internal */
export const PostMultipartRequest$outboundSchema: z.ZodType<
  PostMultipartRequest$Outbound,
  z.ZodTypeDef,
  PostMultipartRequest
> = z.object({
  projectId: z.string().optional(),
  name: z.string().optional(),
  description: z.string().optional(),
  contactId: z.number().int().optional(),
  accessToken: z.string().optional(),
  file: z.lazy(() => FileT$outboundSchema).or(blobLikeSchema),
}).transform((v) => {
  return remap$(v, {
    projectId: "project_id",
    contactId: "contact_id",
    accessToken: "access_token",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostMultipartRequest$ {
  /** @deprecated use `PostMultipartRequest$inboundSchema` instead. */
  export const inboundSchema = PostMultipartRequest$inboundSchema;
  /** @deprecated use `PostMultipartRequest$outboundSchema` instead. */
  export const outboundSchema = PostMultipartRequest$outboundSchema;
  /** @deprecated use `PostMultipartRequest$Outbound` instead. */
  export type Outbound = PostMultipartRequest$Outbound;
}

export function postMultipartRequestToJSON(
  postMultipartRequest: PostMultipartRequest,
): string {
  return JSON.stringify(
    PostMultipartRequest$outboundSchema.parse(postMultipartRequest),
  );
}

export function postMultipartRequestFromJSON(
  jsonString: string,
): SafeParseResult<PostMultipartRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostMultipartRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostMultipartRequest' from JSON`,
  );
}

/** @internal */
export const PostMultipartError$inboundSchema: z.ZodType<
  PostMultipartError,
  z.ZodTypeDef,
  unknown
> = z.object({
  code: z.string().optional(),
  detail: z.string().optional(),
});

/** @internal */
export type PostMultipartError$Outbound = {
  code?: string | undefined;
  detail?: string | undefined;
};

/** @internal */
export const PostMultipartError$outboundSchema: z.ZodType<
  PostMultipartError$Outbound,
  z.ZodTypeDef,
  PostMultipartError
> = z.object({
  code: z.string().optional(),
  detail: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostMultipartError$ {
  /** @deprecated use `PostMultipartError$inboundSchema` instead. */
  export const inboundSchema = PostMultipartError$inboundSchema;
  /** @deprecated use `PostMultipartError$outboundSchema` instead. */
  export const outboundSchema = PostMultipartError$outboundSchema;
  /** @deprecated use `PostMultipartError$Outbound` instead. */
  export type Outbound = PostMultipartError$Outbound;
}

export function postMultipartErrorToJSON(
  postMultipartError: PostMultipartError,
): string {
  return JSON.stringify(
    PostMultipartError$outboundSchema.parse(postMultipartError),
  );
}

export function postMultipartErrorFromJSON(
  jsonString: string,
): SafeParseResult<PostMultipartError, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostMultipartError$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostMultipartError' from JSON`,
  );
}

/** @internal */
export const PostMultipartResponse$inboundSchema: z.ZodType<
  PostMultipartResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().int().optional(),
  name: z.string().optional(),
  type: z.string().optional(),
  created: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  updated: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  duration: z.number().optional(),
  hashed_id: z.string().optional(),
  progress: z.number().optional(),
  thumbnail: models.Thumbnail$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "hashed_id": "hashedId",
  });
});

/** @internal */
export type PostMultipartResponse$Outbound = {
  id?: number | undefined;
  name?: string | undefined;
  type?: string | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  duration?: number | undefined;
  hashed_id?: string | undefined;
  progress?: number | undefined;
  thumbnail?: models.Thumbnail$Outbound | undefined;
};

/** @internal */
export const PostMultipartResponse$outboundSchema: z.ZodType<
  PostMultipartResponse$Outbound,
  z.ZodTypeDef,
  PostMultipartResponse
> = z.object({
  id: z.number().int().optional(),
  name: z.string().optional(),
  type: z.string().optional(),
  created: z.date().transform(v => v.toISOString()).optional(),
  updated: z.date().transform(v => v.toISOString()).optional(),
  duration: z.number().optional(),
  hashedId: z.string().optional(),
  progress: z.number().optional(),
  thumbnail: models.Thumbnail$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    hashedId: "hashed_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostMultipartResponse$ {
  /** @deprecated use `PostMultipartResponse$inboundSchema` instead. */
  export const inboundSchema = PostMultipartResponse$inboundSchema;
  /** @deprecated use `PostMultipartResponse$outboundSchema` instead. */
  export const outboundSchema = PostMultipartResponse$outboundSchema;
  /** @deprecated use `PostMultipartResponse$Outbound` instead. */
  export type Outbound = PostMultipartResponse$Outbound;
}

export function postMultipartResponseToJSON(
  postMultipartResponse: PostMultipartResponse,
): string {
  return JSON.stringify(
    PostMultipartResponse$outboundSchema.parse(postMultipartResponse),
  );
}

export function postMultipartResponseFromJSON(
  jsonString: string,
): SafeParseResult<PostMultipartResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostMultipartResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostMultipartResponse' from JSON`,
  );
}
