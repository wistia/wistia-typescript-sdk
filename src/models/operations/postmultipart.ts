/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { blobLikeSchema } from "../../types/blobs.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

export const PostMultipartServerList = [
  "https://upload.wistia.com",
] as const;

export type PostMultipartGlobals = {
  /**
   * The API version
   */
  xWistiaAPIVersion?: string | undefined;
};

export type FileT = {
  fileName: string;
  content: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

export type PostMultipartRequestBody = {
  /**
   * The hashed id of the project to upload media into.
   */
  projectId?: string | undefined;
  /**
   * A display name to use for the media in Wistia.
   */
  name?: string | undefined;
  /**
   * A description to use for the media in Wistia.
   */
  description?: string | undefined;
  /**
   * A Wistia contact id.
   */
  contactId?: number | undefined;
  /**
   * A 64 character hex string. This parameter can be found on your API access page OR can be the token you received from authenticating via Oauth2. Note this approach is legacy and discouraged. We recommend using Bearer Token authentication.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  accessToken?: string | undefined;
  /**
   * The media file, multipart-form encoded into the request body.
   */
  file: FileT | Blob;
};

export type PostMultipartRequest = {
  /**
   * The API version
   */
  xWistiaAPIVersion?: string | undefined;
  requestBody?: PostMultipartRequestBody | undefined;
};

export type PostMultipartError = {
  code?: string | undefined;
  detail?: string | undefined;
};

/**
 * Response after successfully uploading or importing media
 */
export type PostMultipartResponse = {
  /**
   * A unique numeric identifier for the media within the system.
   */
  id?: number | undefined;
  /**
   * The display name of the media.
   */
  name?: string | undefined;
  /**
   * A string representing what type of media this is.
   */
  type?: string | undefined;
  /**
   * The date when the media was originally uploaded.
   */
  created?: Date | undefined;
  /**
   * The date when the media was last changed.
   */
  updated?: Date | undefined;
  /**
   * Specifies the length (in seconds) for audio and video files.
   */
  duration?: number | undefined;
  /**
   * A unique alphanumeric identifier for this media.
   */
  hashedId?: string | undefined;
  /**
   * A floating point value between 0 and 1 that indicates the progress of the processing for this file.
   */
  progress?: number | undefined;
  thumbnail?: models.Thumbnail | undefined;
};

/** @internal */
export type FileT$Outbound = {
  fileName: string;
  content: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

/** @internal */
export const FileT$outboundSchema: z.ZodType<
  FileT$Outbound,
  z.ZodTypeDef,
  FileT
> = z.object({
  fileName: z.string(),
  content: z.union([
    z.instanceof(ReadableStream<Uint8Array>),
    z.instanceof(Blob),
    z.instanceof(ArrayBuffer),
    z.instanceof(Uint8Array),
  ]),
});

export function fileToJSON(fileT: FileT): string {
  return JSON.stringify(FileT$outboundSchema.parse(fileT));
}

/** @internal */
export type PostMultipartRequestBody$Outbound = {
  project_id?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  contact_id?: number | undefined;
  access_token?: string | undefined;
  file: FileT$Outbound | Blob;
};

/** @internal */
export const PostMultipartRequestBody$outboundSchema: z.ZodType<
  PostMultipartRequestBody$Outbound,
  z.ZodTypeDef,
  PostMultipartRequestBody
> = z.object({
  projectId: z.string().optional(),
  name: z.string().optional(),
  description: z.string().optional(),
  contactId: z.number().int().optional(),
  accessToken: z.string().optional(),
  file: z.lazy(() => FileT$outboundSchema).or(blobLikeSchema),
}).transform((v) => {
  return remap$(v, {
    projectId: "project_id",
    contactId: "contact_id",
    accessToken: "access_token",
  });
});

export function postMultipartRequestBodyToJSON(
  postMultipartRequestBody: PostMultipartRequestBody,
): string {
  return JSON.stringify(
    PostMultipartRequestBody$outboundSchema.parse(postMultipartRequestBody),
  );
}

/** @internal */
export type PostMultipartRequest$Outbound = {
  "X-Wistia-API-Version"?: string | undefined;
  RequestBody?: PostMultipartRequestBody$Outbound | undefined;
};

/** @internal */
export const PostMultipartRequest$outboundSchema: z.ZodType<
  PostMultipartRequest$Outbound,
  z.ZodTypeDef,
  PostMultipartRequest
> = z.object({
  xWistiaAPIVersion: z.string().optional(),
  requestBody: z.lazy(() => PostMultipartRequestBody$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    xWistiaAPIVersion: "X-Wistia-API-Version",
    requestBody: "RequestBody",
  });
});

export function postMultipartRequestToJSON(
  postMultipartRequest: PostMultipartRequest,
): string {
  return JSON.stringify(
    PostMultipartRequest$outboundSchema.parse(postMultipartRequest),
  );
}

/** @internal */
export const PostMultipartError$inboundSchema: z.ZodType<
  PostMultipartError,
  z.ZodTypeDef,
  unknown
> = z.object({
  code: z.string().optional(),
  detail: z.string().optional(),
});

export function postMultipartErrorFromJSON(
  jsonString: string,
): SafeParseResult<PostMultipartError, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostMultipartError$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostMultipartError' from JSON`,
  );
}

/** @internal */
export const PostMultipartResponse$inboundSchema: z.ZodType<
  PostMultipartResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().int().optional(),
  name: z.string().optional(),
  type: z.string().optional(),
  created: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  updated: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  duration: z.number().optional(),
  hashed_id: z.string().optional(),
  progress: z.number().optional(),
  thumbnail: models.Thumbnail$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "hashed_id": "hashedId",
  });
});

export function postMultipartResponseFromJSON(
  jsonString: string,
): SafeParseResult<PostMultipartResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostMultipartResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostMultipartResponse' from JSON`,
  );
}
