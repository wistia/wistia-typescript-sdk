/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The status of whether or not the episode has been published to your channel.
 */
export const PostChannelsChannelHashedIdChannelEpisodesPublishStatus = {
  Draft: "draft",
  Published: "published",
  Scheduled: "scheduled",
} as const;
/**
 * The status of whether or not the episode has been published to your channel.
 */
export type PostChannelsChannelHashedIdChannelEpisodesPublishStatus =
  ClosedEnum<typeof PostChannelsChannelHashedIdChannelEpisodesPublishStatus>;

/**
 * The episode type for your podcast.  This parameter only takes effect if podcasting is enabled for the channel.
 */
export const PostChannelsChannelHashedIdChannelEpisodesEpisodeType = {
  Full: "full",
  Trailer: "trailer",
  Bonus: "bonus",
} as const;
/**
 * The episode type for your podcast.  This parameter only takes effect if podcasting is enabled for the channel.
 */
export type PostChannelsChannelHashedIdChannelEpisodesEpisodeType = ClosedEnum<
  typeof PostChannelsChannelHashedIdChannelEpisodesEpisodeType
>;

export type PostChannelsChannelHashedIdChannelEpisodesRequestBody = {
  /**
   * The alphanumeric hashed ID of the media to be added as a channel episode.
   */
  mediaId?: string | undefined;
  /**
   * The episode's title.  If not provided, the channel episode uses the title of the media used to create it.
   */
  title?: string | undefined;
  /**
   * The episode's description or episode notes.
   */
  description?: string | undefined;
  /**
   * A short summary of the episode that is displayed when space is limited.
   */
  summary?: string | undefined;
  /**
   * The status of whether or not the episode has been published to your channel.
   */
  publishStatus?:
    | PostChannelsChannelHashedIdChannelEpisodesPublishStatus
    | undefined;
  /**
   * The date and time when the episode should be published in UTC timezone. Required when publish_status is 'scheduled'. Must be a valid ISO8601 timestamp in UTC (ending with 'Z').  Can only be provided when publish_status is 'scheduled.'
   */
  publishAt?: Date | undefined;
  /**
   * The episode type for your podcast.  This parameter only takes effect if podcasting is enabled for the channel.
   */
  episodeType?:
    | PostChannelsChannelHashedIdChannelEpisodesEpisodeType
    | undefined;
  /**
   * The episode number for this episode in your podcast.  This parameter only takes effect if podcasting is enabled for the channel.
   */
  episodeNumber?: number | undefined;
  /**
   * Whether this episode contains explicit content.  This parameter only takes effect if podcasting is enabled for the channel.
   */
  explicitContent?: boolean | undefined;
  /**
   * Whether or not to hide this episode from your podcast feed.  Set to true to hide the episode, false to show the episode.  This parameter only takes effect if podcasting is enabled for the channel.
   */
  hideFromFeed?: boolean | undefined;
};

export type PostChannelsChannelHashedIdChannelEpisodesRequest = {
  /**
   * The hashed ID of the channel to add the episode to.
   */
  channelHashedId: string;
  requestBody: PostChannelsChannelHashedIdChannelEpisodesRequestBody;
};

/**
 * A channel episode represents a media that has been added to a channel. Only published
 *
 * @remarks
 * episodes are displayed in a channel.
 */
export type PostChannelsChannelHashedIdChannelEpisodesResponse = {
  /**
   * A unique alphanumeric identifier for the channel episode's channel.
   */
  channelHashedId: string;
  /**
   * The date when the channel episode was originally created.
   */
  created: Date;
  /**
   * A cursor for stable pagination based on current `sort_by` order. You can pass this to `cursor[before]` or `cursor[after]` as a parameter to fetch the records before or after this record in the same sort order. This is only populated if records were fetched with `cursor[enabled]`, or `cursor[before]` or `cursor[after]`.
   */
  cursor?: string | null | undefined;
  /**
   * The channel episode's description or episode notes.
   */
  description: string;
  /**
   * A short summary of the episode that is displayed when space is limited.
   */
  summary: string;
  /**
   * A unique alphanumeric identifier for the channel episode.
   */
  hashedId: string;
  /**
   * A unique alphanumeric identifier for the channel episode's media.
   */
  mediaHashedId: string;
  /**
   * Whether the channel episode has been published or is still in draft form.
   */
  published: boolean;
  /**
   * The date and time when the episode is scheduled to be published in UTC timezone (only present when publish_status is 'scheduled').
   */
  publishAt?: Date | undefined;
  /**
   * The title of the channel episode
   */
  title: string | null;
  /**
   * The date when the channel was last updated.
   */
  updated: Date;
};

/** @internal */
export const PostChannelsChannelHashedIdChannelEpisodesPublishStatus$outboundSchema:
  z.ZodNativeEnum<
    typeof PostChannelsChannelHashedIdChannelEpisodesPublishStatus
  > = z.nativeEnum(PostChannelsChannelHashedIdChannelEpisodesPublishStatus);

/** @internal */
export const PostChannelsChannelHashedIdChannelEpisodesEpisodeType$outboundSchema:
  z.ZodNativeEnum<
    typeof PostChannelsChannelHashedIdChannelEpisodesEpisodeType
  > = z.nativeEnum(PostChannelsChannelHashedIdChannelEpisodesEpisodeType);

/** @internal */
export type PostChannelsChannelHashedIdChannelEpisodesRequestBody$Outbound = {
  media_id?: string | undefined;
  title?: string | undefined;
  description?: string | undefined;
  summary?: string | undefined;
  publish_status?: string | undefined;
  publish_at?: string | undefined;
  episode_type?: string | undefined;
  episode_number?: number | undefined;
  explicit_content?: boolean | undefined;
  hide_from_feed?: boolean | undefined;
};

/** @internal */
export const PostChannelsChannelHashedIdChannelEpisodesRequestBody$outboundSchema:
  z.ZodType<
    PostChannelsChannelHashedIdChannelEpisodesRequestBody$Outbound,
    z.ZodTypeDef,
    PostChannelsChannelHashedIdChannelEpisodesRequestBody
  > = z.object({
    mediaId: z.string().optional(),
    title: z.string().optional(),
    description: z.string().optional(),
    summary: z.string().optional(),
    publishStatus:
      PostChannelsChannelHashedIdChannelEpisodesPublishStatus$outboundSchema
        .optional(),
    publishAt: z.date().transform(v => v.toISOString()).optional(),
    episodeType:
      PostChannelsChannelHashedIdChannelEpisodesEpisodeType$outboundSchema
        .optional(),
    episodeNumber: z.number().int().optional(),
    explicitContent: z.boolean().optional(),
    hideFromFeed: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      mediaId: "media_id",
      publishStatus: "publish_status",
      publishAt: "publish_at",
      episodeType: "episode_type",
      episodeNumber: "episode_number",
      explicitContent: "explicit_content",
      hideFromFeed: "hide_from_feed",
    });
  });

export function postChannelsChannelHashedIdChannelEpisodesRequestBodyToJSON(
  postChannelsChannelHashedIdChannelEpisodesRequestBody:
    PostChannelsChannelHashedIdChannelEpisodesRequestBody,
): string {
  return JSON.stringify(
    PostChannelsChannelHashedIdChannelEpisodesRequestBody$outboundSchema.parse(
      postChannelsChannelHashedIdChannelEpisodesRequestBody,
    ),
  );
}

/** @internal */
export type PostChannelsChannelHashedIdChannelEpisodesRequest$Outbound = {
  channelHashedId: string;
  RequestBody: PostChannelsChannelHashedIdChannelEpisodesRequestBody$Outbound;
};

/** @internal */
export const PostChannelsChannelHashedIdChannelEpisodesRequest$outboundSchema:
  z.ZodType<
    PostChannelsChannelHashedIdChannelEpisodesRequest$Outbound,
    z.ZodTypeDef,
    PostChannelsChannelHashedIdChannelEpisodesRequest
  > = z.object({
    channelHashedId: z.string(),
    requestBody: z.lazy(() =>
      PostChannelsChannelHashedIdChannelEpisodesRequestBody$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      requestBody: "RequestBody",
    });
  });

export function postChannelsChannelHashedIdChannelEpisodesRequestToJSON(
  postChannelsChannelHashedIdChannelEpisodesRequest:
    PostChannelsChannelHashedIdChannelEpisodesRequest,
): string {
  return JSON.stringify(
    PostChannelsChannelHashedIdChannelEpisodesRequest$outboundSchema.parse(
      postChannelsChannelHashedIdChannelEpisodesRequest,
    ),
  );
}

/** @internal */
export const PostChannelsChannelHashedIdChannelEpisodesResponse$inboundSchema:
  z.ZodType<
    PostChannelsChannelHashedIdChannelEpisodesResponse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    channel_hashed_id: z.string(),
    created: z.string().datetime({ offset: true }).transform(v => new Date(v)),
    cursor: z.nullable(z.string()).optional(),
    description: z.string(),
    summary: z.string(),
    hashed_id: z.string(),
    media_hashed_id: z.string(),
    published: z.boolean(),
    publish_at: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ).optional(),
    title: z.nullable(z.string()),
    updated: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  }).transform((v) => {
    return remap$(v, {
      "channel_hashed_id": "channelHashedId",
      "hashed_id": "hashedId",
      "media_hashed_id": "mediaHashedId",
      "publish_at": "publishAt",
    });
  });

export function postChannelsChannelHashedIdChannelEpisodesResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  PostChannelsChannelHashedIdChannelEpisodesResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostChannelsChannelHashedIdChannelEpisodesResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostChannelsChannelHashedIdChannelEpisodesResponse' from JSON`,
  );
}
