/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The status of whether or not the episode has been published to your channel.
 */
export const PublishStatus = {
  Draft: "draft",
  Published: "published",
  Scheduled: "scheduled",
} as const;
/**
 * The status of whether or not the episode has been published to your channel.
 */
export type PublishStatus = ClosedEnum<typeof PublishStatus>;

/**
 * The episode type for your podcast.  This parameter only takes effect if podcasting is enabled for the channel.
 */
export const EpisodeType = {
  Full: "full",
  Trailer: "trailer",
  Bonus: "bonus",
} as const;
/**
 * The episode type for your podcast.  This parameter only takes effect if podcasting is enabled for the channel.
 */
export type EpisodeType = ClosedEnum<typeof EpisodeType>;

export type PostChannelsChannelHashedIdChannelEpisodesRequestBody = {
  /**
   * The alphanumeric hashed ID of the media to be added as a channel episode.
   */
  mediaId?: string | undefined;
  /**
   * The episode's title.  If not provided, the channel episode uses the title of the media used to create it.
   */
  title?: string | undefined;
  /**
   * The episode's description or episode notes.
   */
  description?: string | undefined;
  /**
   * A short summary of the episode that is displayed when space is limited.
   */
  summary?: string | undefined;
  /**
   * The status of whether or not the episode has been published to your channel.
   */
  publishStatus?: PublishStatus | undefined;
  /**
   * The date and time when the episode should be published in UTC timezone. Required when publish_status is 'scheduled'. Must be a valid ISO8601 timestamp in UTC (ending with 'Z').  Can only be provided when publish_status is 'scheduled.'
   */
  publishAt?: Date | undefined;
  /**
   * The episode type for your podcast.  This parameter only takes effect if podcasting is enabled for the channel.
   */
  episodeType?: EpisodeType | undefined;
  /**
   * The episode number for this episode in your podcast.  This parameter only takes effect if podcasting is enabled for the channel.
   */
  episodeNumber?: number | undefined;
  /**
   * Whether this episode contains explicit content.  This parameter only takes effect if podcasting is enabled for the channel.
   */
  explicitContent?: boolean | undefined;
  /**
   * Whether or not to hide this episode from your podcast feed.  Set to true to hide the episode, false to show the episode.  This parameter only takes effect if podcasting is enabled for the channel.
   */
  hideFromFeed?: boolean | undefined;
};

export type PostChannelsChannelHashedIdChannelEpisodesRequest = {
  /**
   * The hashed ID of the channel to add the episode to.
   */
  channelHashedId: string;
  requestBody: PostChannelsChannelHashedIdChannelEpisodesRequestBody;
};

/**
 * Channel Episode creation successful
 */
export type PostChannelsChannelHashedIdChannelEpisodesResponse = {
  /**
   * A unique alphanumeric identifier for the channel episode's channel.
   */
  channelHashedId: string;
  /**
   * The date when the channel episode was originally created.
   */
  created: Date;
  /**
   * The channel episode's description or episode notes.
   */
  description: string;
  /**
   * A short summary of the episode that is displayed when space is limited.
   */
  summary: string;
  /**
   * A unique alphanumeric identifier for the channel episode.
   */
  hashedId: string;
  /**
   * A unique alphanumeric identifier for the channel episode's media.
   */
  mediaHashedId: string;
  /**
   * Whether the channel episode has been published or is still in draft form.
   */
  published: boolean;
  /**
   * The date and time when the episode is scheduled to be published in UTC timezone (only present when publish_status is 'scheduled').
   */
  publishAt?: Date | undefined;
  /**
   * The title of the channel episode
   */
  title: string | null;
  /**
   * The date when the channel was last updated.
   */
  updated: Date;
};

/** @internal */
export const PublishStatus$inboundSchema: z.ZodNativeEnum<
  typeof PublishStatus
> = z.nativeEnum(PublishStatus);

/** @internal */
export const PublishStatus$outboundSchema: z.ZodNativeEnum<
  typeof PublishStatus
> = PublishStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PublishStatus$ {
  /** @deprecated use `PublishStatus$inboundSchema` instead. */
  export const inboundSchema = PublishStatus$inboundSchema;
  /** @deprecated use `PublishStatus$outboundSchema` instead. */
  export const outboundSchema = PublishStatus$outboundSchema;
}

/** @internal */
export const EpisodeType$inboundSchema: z.ZodNativeEnum<typeof EpisodeType> = z
  .nativeEnum(EpisodeType);

/** @internal */
export const EpisodeType$outboundSchema: z.ZodNativeEnum<typeof EpisodeType> =
  EpisodeType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EpisodeType$ {
  /** @deprecated use `EpisodeType$inboundSchema` instead. */
  export const inboundSchema = EpisodeType$inboundSchema;
  /** @deprecated use `EpisodeType$outboundSchema` instead. */
  export const outboundSchema = EpisodeType$outboundSchema;
}

/** @internal */
export const PostChannelsChannelHashedIdChannelEpisodesRequestBody$inboundSchema:
  z.ZodType<
    PostChannelsChannelHashedIdChannelEpisodesRequestBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    media_id: z.string().optional(),
    title: z.string().optional(),
    description: z.string().optional(),
    summary: z.string().optional(),
    publish_status: PublishStatus$inboundSchema.optional(),
    publish_at: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ).optional(),
    episode_type: EpisodeType$inboundSchema.optional(),
    episode_number: z.number().int().optional(),
    explicit_content: z.boolean().optional(),
    hide_from_feed: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "media_id": "mediaId",
      "publish_status": "publishStatus",
      "publish_at": "publishAt",
      "episode_type": "episodeType",
      "episode_number": "episodeNumber",
      "explicit_content": "explicitContent",
      "hide_from_feed": "hideFromFeed",
    });
  });

/** @internal */
export type PostChannelsChannelHashedIdChannelEpisodesRequestBody$Outbound = {
  media_id?: string | undefined;
  title?: string | undefined;
  description?: string | undefined;
  summary?: string | undefined;
  publish_status?: string | undefined;
  publish_at?: string | undefined;
  episode_type?: string | undefined;
  episode_number?: number | undefined;
  explicit_content?: boolean | undefined;
  hide_from_feed?: boolean | undefined;
};

/** @internal */
export const PostChannelsChannelHashedIdChannelEpisodesRequestBody$outboundSchema:
  z.ZodType<
    PostChannelsChannelHashedIdChannelEpisodesRequestBody$Outbound,
    z.ZodTypeDef,
    PostChannelsChannelHashedIdChannelEpisodesRequestBody
  > = z.object({
    mediaId: z.string().optional(),
    title: z.string().optional(),
    description: z.string().optional(),
    summary: z.string().optional(),
    publishStatus: PublishStatus$outboundSchema.optional(),
    publishAt: z.date().transform(v => v.toISOString()).optional(),
    episodeType: EpisodeType$outboundSchema.optional(),
    episodeNumber: z.number().int().optional(),
    explicitContent: z.boolean().optional(),
    hideFromFeed: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      mediaId: "media_id",
      publishStatus: "publish_status",
      publishAt: "publish_at",
      episodeType: "episode_type",
      episodeNumber: "episode_number",
      explicitContent: "explicit_content",
      hideFromFeed: "hide_from_feed",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostChannelsChannelHashedIdChannelEpisodesRequestBody$ {
  /** @deprecated use `PostChannelsChannelHashedIdChannelEpisodesRequestBody$inboundSchema` instead. */
  export const inboundSchema =
    PostChannelsChannelHashedIdChannelEpisodesRequestBody$inboundSchema;
  /** @deprecated use `PostChannelsChannelHashedIdChannelEpisodesRequestBody$outboundSchema` instead. */
  export const outboundSchema =
    PostChannelsChannelHashedIdChannelEpisodesRequestBody$outboundSchema;
  /** @deprecated use `PostChannelsChannelHashedIdChannelEpisodesRequestBody$Outbound` instead. */
  export type Outbound =
    PostChannelsChannelHashedIdChannelEpisodesRequestBody$Outbound;
}

export function postChannelsChannelHashedIdChannelEpisodesRequestBodyToJSON(
  postChannelsChannelHashedIdChannelEpisodesRequestBody:
    PostChannelsChannelHashedIdChannelEpisodesRequestBody,
): string {
  return JSON.stringify(
    PostChannelsChannelHashedIdChannelEpisodesRequestBody$outboundSchema.parse(
      postChannelsChannelHashedIdChannelEpisodesRequestBody,
    ),
  );
}

export function postChannelsChannelHashedIdChannelEpisodesRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  PostChannelsChannelHashedIdChannelEpisodesRequestBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostChannelsChannelHashedIdChannelEpisodesRequestBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostChannelsChannelHashedIdChannelEpisodesRequestBody' from JSON`,
  );
}

/** @internal */
export const PostChannelsChannelHashedIdChannelEpisodesRequest$inboundSchema:
  z.ZodType<
    PostChannelsChannelHashedIdChannelEpisodesRequest,
    z.ZodTypeDef,
    unknown
  > = z.object({
    channelHashedId: z.string(),
    RequestBody: z.lazy(() =>
      PostChannelsChannelHashedIdChannelEpisodesRequestBody$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "RequestBody": "requestBody",
    });
  });

/** @internal */
export type PostChannelsChannelHashedIdChannelEpisodesRequest$Outbound = {
  channelHashedId: string;
  RequestBody: PostChannelsChannelHashedIdChannelEpisodesRequestBody$Outbound;
};

/** @internal */
export const PostChannelsChannelHashedIdChannelEpisodesRequest$outboundSchema:
  z.ZodType<
    PostChannelsChannelHashedIdChannelEpisodesRequest$Outbound,
    z.ZodTypeDef,
    PostChannelsChannelHashedIdChannelEpisodesRequest
  > = z.object({
    channelHashedId: z.string(),
    requestBody: z.lazy(() =>
      PostChannelsChannelHashedIdChannelEpisodesRequestBody$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      requestBody: "RequestBody",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostChannelsChannelHashedIdChannelEpisodesRequest$ {
  /** @deprecated use `PostChannelsChannelHashedIdChannelEpisodesRequest$inboundSchema` instead. */
  export const inboundSchema =
    PostChannelsChannelHashedIdChannelEpisodesRequest$inboundSchema;
  /** @deprecated use `PostChannelsChannelHashedIdChannelEpisodesRequest$outboundSchema` instead. */
  export const outboundSchema =
    PostChannelsChannelHashedIdChannelEpisodesRequest$outboundSchema;
  /** @deprecated use `PostChannelsChannelHashedIdChannelEpisodesRequest$Outbound` instead. */
  export type Outbound =
    PostChannelsChannelHashedIdChannelEpisodesRequest$Outbound;
}

export function postChannelsChannelHashedIdChannelEpisodesRequestToJSON(
  postChannelsChannelHashedIdChannelEpisodesRequest:
    PostChannelsChannelHashedIdChannelEpisodesRequest,
): string {
  return JSON.stringify(
    PostChannelsChannelHashedIdChannelEpisodesRequest$outboundSchema.parse(
      postChannelsChannelHashedIdChannelEpisodesRequest,
    ),
  );
}

export function postChannelsChannelHashedIdChannelEpisodesRequestFromJSON(
  jsonString: string,
): SafeParseResult<
  PostChannelsChannelHashedIdChannelEpisodesRequest,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostChannelsChannelHashedIdChannelEpisodesRequest$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostChannelsChannelHashedIdChannelEpisodesRequest' from JSON`,
  );
}

/** @internal */
export const PostChannelsChannelHashedIdChannelEpisodesResponse$inboundSchema:
  z.ZodType<
    PostChannelsChannelHashedIdChannelEpisodesResponse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    channelHashedId: z.string(),
    created: z.string().datetime({ offset: true }).transform(v => new Date(v)),
    description: z.string(),
    summary: z.string(),
    hashedId: z.string(),
    mediaHashedId: z.string(),
    published: z.boolean(),
    publish_at: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ).optional(),
    title: z.nullable(z.string()),
    updated: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  }).transform((v) => {
    return remap$(v, {
      "publish_at": "publishAt",
    });
  });

/** @internal */
export type PostChannelsChannelHashedIdChannelEpisodesResponse$Outbound = {
  channelHashedId: string;
  created: string;
  description: string;
  summary: string;
  hashedId: string;
  mediaHashedId: string;
  published: boolean;
  publish_at?: string | undefined;
  title: string | null;
  updated: string;
};

/** @internal */
export const PostChannelsChannelHashedIdChannelEpisodesResponse$outboundSchema:
  z.ZodType<
    PostChannelsChannelHashedIdChannelEpisodesResponse$Outbound,
    z.ZodTypeDef,
    PostChannelsChannelHashedIdChannelEpisodesResponse
  > = z.object({
    channelHashedId: z.string(),
    created: z.date().transform(v => v.toISOString()),
    description: z.string(),
    summary: z.string(),
    hashedId: z.string(),
    mediaHashedId: z.string(),
    published: z.boolean(),
    publishAt: z.date().transform(v => v.toISOString()).optional(),
    title: z.nullable(z.string()),
    updated: z.date().transform(v => v.toISOString()),
  }).transform((v) => {
    return remap$(v, {
      publishAt: "publish_at",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostChannelsChannelHashedIdChannelEpisodesResponse$ {
  /** @deprecated use `PostChannelsChannelHashedIdChannelEpisodesResponse$inboundSchema` instead. */
  export const inboundSchema =
    PostChannelsChannelHashedIdChannelEpisodesResponse$inboundSchema;
  /** @deprecated use `PostChannelsChannelHashedIdChannelEpisodesResponse$outboundSchema` instead. */
  export const outboundSchema =
    PostChannelsChannelHashedIdChannelEpisodesResponse$outboundSchema;
  /** @deprecated use `PostChannelsChannelHashedIdChannelEpisodesResponse$Outbound` instead. */
  export type Outbound =
    PostChannelsChannelHashedIdChannelEpisodesResponse$Outbound;
}

export function postChannelsChannelHashedIdChannelEpisodesResponseToJSON(
  postChannelsChannelHashedIdChannelEpisodesResponse:
    PostChannelsChannelHashedIdChannelEpisodesResponse,
): string {
  return JSON.stringify(
    PostChannelsChannelHashedIdChannelEpisodesResponse$outboundSchema.parse(
      postChannelsChannelHashedIdChannelEpisodesResponse,
    ),
  );
}

export function postChannelsChannelHashedIdChannelEpisodesResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  PostChannelsChannelHashedIdChannelEpisodesResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostChannelsChannelHashedIdChannelEpisodesResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostChannelsChannelHashedIdChannelEpisodesResponse' from JSON`,
  );
}
