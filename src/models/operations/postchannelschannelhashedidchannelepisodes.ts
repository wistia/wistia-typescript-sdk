/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The status of whether or not the episode has been published to your channel.
 */
export const PublishStatus = {
  Draft: "draft",
  Published: "published",
  Scheduled: "scheduled",
} as const;
/**
 * The status of whether or not the episode has been published to your channel.
 */
export type PublishStatus = ClosedEnum<typeof PublishStatus>;

/**
 * The episode type for your podcast.  This parameter only takes effect if podcasting is enabled for the channel.
 */
export const EpisodeType = {
  Full: "full",
  Trailer: "trailer",
  Bonus: "bonus",
} as const;
/**
 * The episode type for your podcast.  This parameter only takes effect if podcasting is enabled for the channel.
 */
export type EpisodeType = ClosedEnum<typeof EpisodeType>;

export type PostChannelsChannelHashedIdChannelEpisodesRequestBody = {
  /**
   * The alphanumeric hashed ID of the media to be added as a channel episode.
   */
  mediaId?: string | undefined;
  /**
   * The episode's title.  If not provided, the channel episode uses the title of the media used to create it.
   */
  title?: string | undefined;
  /**
   * The episode's description or episode notes.
   */
  description?: string | undefined;
  /**
   * A short summary of the episode that is displayed when space is limited.
   */
  summary?: string | undefined;
  /**
   * The status of whether or not the episode has been published to your channel.
   */
  publishStatus?: PublishStatus | undefined;
  /**
   * The date and time when the episode should be published in UTC timezone. Required when publish_status is 'scheduled'. Must be a valid ISO8601 timestamp in UTC (ending with 'Z').  Can only be provided when publish_status is 'scheduled.'
   */
  publishAt?: Date | undefined;
  /**
   * The episode type for your podcast.  This parameter only takes effect if podcasting is enabled for the channel.
   */
  episodeType?: EpisodeType | undefined;
  /**
   * The episode number for this episode in your podcast.  This parameter only takes effect if podcasting is enabled for the channel.
   */
  episodeNumber?: number | undefined;
  /**
   * Whether this episode contains explicit content.  This parameter only takes effect if podcasting is enabled for the channel.
   */
  explicitContent?: boolean | undefined;
  /**
   * Whether or not to hide this episode from your podcast feed.  Set to true to hide the episode, false to show the episode.  This parameter only takes effect if podcasting is enabled for the channel.
   */
  hideFromFeed?: boolean | undefined;
};

export type PostChannelsChannelHashedIdChannelEpisodesRequest = {
  /**
   * The hashed ID of the channel to add the episode to.
   */
  channelHashedId: string;
  requestBody: PostChannelsChannelHashedIdChannelEpisodesRequestBody;
};

/**
 * Channel Episode creation successful
 */
export type PostChannelsChannelHashedIdChannelEpisodesResponse = {
  /**
   * A unique alphanumeric identifier for the channel episode's channel.
   */
  channelHashedId: string;
  /**
   * The date when the channel episode was originally created.
   */
  created: Date;
  /**
   * The channel episode's description or episode notes.
   */
  description: string;
  /**
   * A short summary of the episode that is displayed when space is limited.
   */
  summary: string;
  /**
   * A unique alphanumeric identifier for the channel episode.
   */
  hashedId: string;
  /**
   * A unique alphanumeric identifier for the channel episode's media.
   */
  mediaHashedId: string;
  /**
   * Whether the channel episode has been published or is still in draft form.
   */
  published: boolean;
  /**
   * The date and time when the episode is scheduled to be published in UTC timezone (only present when publish_status is 'scheduled').
   */
  publishAt?: Date | undefined;
  /**
   * The title of the channel episode
   */
  title: string | null;
  /**
   * The date when the channel was last updated.
   */
  updated: Date;
};

/** @internal */
export const PublishStatus$outboundSchema: z.ZodNativeEnum<
  typeof PublishStatus
> = z.nativeEnum(PublishStatus);

/** @internal */
export const EpisodeType$outboundSchema: z.ZodNativeEnum<typeof EpisodeType> = z
  .nativeEnum(EpisodeType);

/** @internal */
export type PostChannelsChannelHashedIdChannelEpisodesRequestBody$Outbound = {
  media_id?: string | undefined;
  title?: string | undefined;
  description?: string | undefined;
  summary?: string | undefined;
  publish_status?: string | undefined;
  publish_at?: string | undefined;
  episode_type?: string | undefined;
  episode_number?: number | undefined;
  explicit_content?: boolean | undefined;
  hide_from_feed?: boolean | undefined;
};

/** @internal */
export const PostChannelsChannelHashedIdChannelEpisodesRequestBody$outboundSchema:
  z.ZodType<
    PostChannelsChannelHashedIdChannelEpisodesRequestBody$Outbound,
    z.ZodTypeDef,
    PostChannelsChannelHashedIdChannelEpisodesRequestBody
  > = z.object({
    mediaId: z.string().optional(),
    title: z.string().optional(),
    description: z.string().optional(),
    summary: z.string().optional(),
    publishStatus: PublishStatus$outboundSchema.optional(),
    publishAt: z.date().transform(v => v.toISOString()).optional(),
    episodeType: EpisodeType$outboundSchema.optional(),
    episodeNumber: z.number().int().optional(),
    explicitContent: z.boolean().optional(),
    hideFromFeed: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      mediaId: "media_id",
      publishStatus: "publish_status",
      publishAt: "publish_at",
      episodeType: "episode_type",
      episodeNumber: "episode_number",
      explicitContent: "explicit_content",
      hideFromFeed: "hide_from_feed",
    });
  });

export function postChannelsChannelHashedIdChannelEpisodesRequestBodyToJSON(
  postChannelsChannelHashedIdChannelEpisodesRequestBody:
    PostChannelsChannelHashedIdChannelEpisodesRequestBody,
): string {
  return JSON.stringify(
    PostChannelsChannelHashedIdChannelEpisodesRequestBody$outboundSchema.parse(
      postChannelsChannelHashedIdChannelEpisodesRequestBody,
    ),
  );
}

/** @internal */
export type PostChannelsChannelHashedIdChannelEpisodesRequest$Outbound = {
  channelHashedId: string;
  RequestBody: PostChannelsChannelHashedIdChannelEpisodesRequestBody$Outbound;
};

/** @internal */
export const PostChannelsChannelHashedIdChannelEpisodesRequest$outboundSchema:
  z.ZodType<
    PostChannelsChannelHashedIdChannelEpisodesRequest$Outbound,
    z.ZodTypeDef,
    PostChannelsChannelHashedIdChannelEpisodesRequest
  > = z.object({
    channelHashedId: z.string(),
    requestBody: z.lazy(() =>
      PostChannelsChannelHashedIdChannelEpisodesRequestBody$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      requestBody: "RequestBody",
    });
  });

export function postChannelsChannelHashedIdChannelEpisodesRequestToJSON(
  postChannelsChannelHashedIdChannelEpisodesRequest:
    PostChannelsChannelHashedIdChannelEpisodesRequest,
): string {
  return JSON.stringify(
    PostChannelsChannelHashedIdChannelEpisodesRequest$outboundSchema.parse(
      postChannelsChannelHashedIdChannelEpisodesRequest,
    ),
  );
}

/** @internal */
export const PostChannelsChannelHashedIdChannelEpisodesResponse$inboundSchema:
  z.ZodType<
    PostChannelsChannelHashedIdChannelEpisodesResponse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    channelHashedId: z.string(),
    created: z.string().datetime({ offset: true }).transform(v => new Date(v)),
    description: z.string(),
    summary: z.string(),
    hashedId: z.string(),
    mediaHashedId: z.string(),
    published: z.boolean(),
    publish_at: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ).optional(),
    title: z.nullable(z.string()),
    updated: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  }).transform((v) => {
    return remap$(v, {
      "publish_at": "publishAt",
    });
  });

export function postChannelsChannelHashedIdChannelEpisodesResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  PostChannelsChannelHashedIdChannelEpisodesResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostChannelsChannelHashedIdChannelEpisodesResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostChannelsChannelHashedIdChannelEpisodesResponse' from JSON`,
  );
}
