/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

export const PostFormServerList = [
  "https://upload.wistia.com",
] as const;

export type PostFormRequest = {
  /**
   * The hashed id of the project to upload media into.
   */
  projectId?: string | undefined;
  /**
   * A display name to use for the media in Wistia.
   */
  name?: string | undefined;
  /**
   * A description to use for the media in Wistia.
   */
  description?: string | undefined;
  /**
   * A Wistia contact id.
   */
  contactId?: number | undefined;
  /**
   * A 64 character hex string. This parameter can be found on your API access page OR can be the token you received from authenticating via Oauth2. Note this approach is legacy and discouraged. We recommend using Bearer Token authentication.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  accessToken?: string | undefined;
  /**
   * The web location of the media file to import.
   */
  url: string;
  /**
   * Inform the encoding service that this upload can be considered lower priority than others. This is especially useful for platform customers doing bulk uploads or migrations. Setting this to "false" has no effect.
   */
  lowPriority?: boolean | undefined;
};

export type PostFormError = {
  code?: string | undefined;
  detail?: string | undefined;
};

/**
 * Response after successfully uploading or importing media
 */
export type PostFormResponse = {
  /**
   * A unique numeric identifier for the media within the system.
   */
  id?: number | undefined;
  /**
   * The display name of the media.
   */
  name?: string | undefined;
  /**
   * A string representing what type of media this is.
   */
  type?: string | undefined;
  /**
   * The date when the media was originally uploaded.
   */
  created?: Date | undefined;
  /**
   * The date when the media was last changed.
   */
  updated?: Date | undefined;
  /**
   * Specifies the length (in seconds) for audio and video files.
   */
  duration?: number | undefined;
  /**
   * A unique alphanumeric identifier for this media.
   */
  hashedId?: string | undefined;
  /**
   * A floating point value between 0 and 1 that indicates the progress of the processing for this file.
   */
  progress?: number | undefined;
  thumbnail?: models.Thumbnail | undefined;
};

/** @internal */
export const PostFormRequest$inboundSchema: z.ZodType<
  PostFormRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  project_id: z.string().optional(),
  name: z.string().optional(),
  description: z.string().optional(),
  contact_id: z.number().int().optional(),
  access_token: z.string().optional(),
  url: z.string(),
  low_priority: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "project_id": "projectId",
    "contact_id": "contactId",
    "access_token": "accessToken",
    "low_priority": "lowPriority",
  });
});

/** @internal */
export type PostFormRequest$Outbound = {
  project_id?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  contact_id?: number | undefined;
  access_token?: string | undefined;
  url: string;
  low_priority?: boolean | undefined;
};

/** @internal */
export const PostFormRequest$outboundSchema: z.ZodType<
  PostFormRequest$Outbound,
  z.ZodTypeDef,
  PostFormRequest
> = z.object({
  projectId: z.string().optional(),
  name: z.string().optional(),
  description: z.string().optional(),
  contactId: z.number().int().optional(),
  accessToken: z.string().optional(),
  url: z.string(),
  lowPriority: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    projectId: "project_id",
    contactId: "contact_id",
    accessToken: "access_token",
    lowPriority: "low_priority",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostFormRequest$ {
  /** @deprecated use `PostFormRequest$inboundSchema` instead. */
  export const inboundSchema = PostFormRequest$inboundSchema;
  /** @deprecated use `PostFormRequest$outboundSchema` instead. */
  export const outboundSchema = PostFormRequest$outboundSchema;
  /** @deprecated use `PostFormRequest$Outbound` instead. */
  export type Outbound = PostFormRequest$Outbound;
}

export function postFormRequestToJSON(
  postFormRequest: PostFormRequest,
): string {
  return JSON.stringify(PostFormRequest$outboundSchema.parse(postFormRequest));
}

export function postFormRequestFromJSON(
  jsonString: string,
): SafeParseResult<PostFormRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostFormRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostFormRequest' from JSON`,
  );
}

/** @internal */
export const PostFormError$inboundSchema: z.ZodType<
  PostFormError,
  z.ZodTypeDef,
  unknown
> = z.object({
  code: z.string().optional(),
  detail: z.string().optional(),
});

/** @internal */
export type PostFormError$Outbound = {
  code?: string | undefined;
  detail?: string | undefined;
};

/** @internal */
export const PostFormError$outboundSchema: z.ZodType<
  PostFormError$Outbound,
  z.ZodTypeDef,
  PostFormError
> = z.object({
  code: z.string().optional(),
  detail: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostFormError$ {
  /** @deprecated use `PostFormError$inboundSchema` instead. */
  export const inboundSchema = PostFormError$inboundSchema;
  /** @deprecated use `PostFormError$outboundSchema` instead. */
  export const outboundSchema = PostFormError$outboundSchema;
  /** @deprecated use `PostFormError$Outbound` instead. */
  export type Outbound = PostFormError$Outbound;
}

export function postFormErrorToJSON(postFormError: PostFormError): string {
  return JSON.stringify(PostFormError$outboundSchema.parse(postFormError));
}

export function postFormErrorFromJSON(
  jsonString: string,
): SafeParseResult<PostFormError, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostFormError$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostFormError' from JSON`,
  );
}

/** @internal */
export const PostFormResponse$inboundSchema: z.ZodType<
  PostFormResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().int().optional(),
  name: z.string().optional(),
  type: z.string().optional(),
  created: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  updated: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  duration: z.number().optional(),
  hashed_id: z.string().optional(),
  progress: z.number().optional(),
  thumbnail: models.Thumbnail$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "hashed_id": "hashedId",
  });
});

/** @internal */
export type PostFormResponse$Outbound = {
  id?: number | undefined;
  name?: string | undefined;
  type?: string | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  duration?: number | undefined;
  hashed_id?: string | undefined;
  progress?: number | undefined;
  thumbnail?: models.Thumbnail$Outbound | undefined;
};

/** @internal */
export const PostFormResponse$outboundSchema: z.ZodType<
  PostFormResponse$Outbound,
  z.ZodTypeDef,
  PostFormResponse
> = z.object({
  id: z.number().int().optional(),
  name: z.string().optional(),
  type: z.string().optional(),
  created: z.date().transform(v => v.toISOString()).optional(),
  updated: z.date().transform(v => v.toISOString()).optional(),
  duration: z.number().optional(),
  hashedId: z.string().optional(),
  progress: z.number().optional(),
  thumbnail: models.Thumbnail$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    hashedId: "hashed_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostFormResponse$ {
  /** @deprecated use `PostFormResponse$inboundSchema` instead. */
  export const inboundSchema = PostFormResponse$inboundSchema;
  /** @deprecated use `PostFormResponse$outboundSchema` instead. */
  export const outboundSchema = PostFormResponse$outboundSchema;
  /** @deprecated use `PostFormResponse$Outbound` instead. */
  export type Outbound = PostFormResponse$Outbound;
}

export function postFormResponseToJSON(
  postFormResponse: PostFormResponse,
): string {
  return JSON.stringify(
    PostFormResponse$outboundSchema.parse(postFormResponse),
  );
}

export function postFormResponseFromJSON(
  jsonString: string,
): SafeParseResult<PostFormResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostFormResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostFormResponse' from JSON`,
  );
}
