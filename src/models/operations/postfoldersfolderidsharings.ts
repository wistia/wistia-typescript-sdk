/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Default is "1". Set to "0" to allow access without a password.
 */
export const RequirePasswordEnum = {
  Zero: "0",
  One: "1",
} as const;
/**
 * Default is "1". Set to "0" to allow access without a password.
 */
export type RequirePasswordEnum = ClosedEnum<typeof RequirePasswordEnum>;

export type RequirePassword = RequirePasswordEnum | boolean;

/**
 * Default is "0". Set to "1" to allow the user to share the folder with others.
 */
export const CanShareEnum = {
  Zero: "0",
  One: "1",
} as const;
/**
 * Default is "0". Set to "1" to allow the user to share the folder with others.
 */
export type CanShareEnum = ClosedEnum<typeof CanShareEnum>;

export type CanShare = CanShareEnum | boolean;

/**
 * Default is "0". Set to "1" to allow the user to download files from the folder.
 */
export const CanDownloadEnum = {
  Zero: "0",
  One: "1",
} as const;
/**
 * Default is "0". Set to "1" to allow the user to download files from the folder.
 */
export type CanDownloadEnum = ClosedEnum<typeof CanDownloadEnum>;

export type CanDownload = CanDownloadEnum | boolean;

/**
 * Default is "0". Set to "1" to allow the user to upload files to the folder.
 */
export const CanUploadEnum = {
  Zero: "0",
  One: "1",
} as const;
/**
 * Default is "0". Set to "1" to allow the user to upload files to the folder.
 */
export type CanUploadEnum = ClosedEnum<typeof CanUploadEnum>;

export type CanUpload = CanUploadEnum | boolean;

/**
 * Deprecated! Email notifications are always sent now.
 *
 * @deprecated enum: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export const SendEmailNotification = {
  Zero: "0",
  One: "1",
} as const;
/**
 * Deprecated! Email notifications are always sent now.
 *
 * @deprecated enum: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type SendEmailNotification = ClosedEnum<typeof SendEmailNotification>;

export type PostFoldersFolderIdSharingsSharingRequest = {
  /**
   * The email address of the person with whom you want to share the folder.
   */
  with: string;
  requirePassword?: RequirePasswordEnum | boolean | undefined;
  canShare?: CanShareEnum | boolean | undefined;
  canDownload?: CanDownloadEnum | boolean | undefined;
  canUpload?: CanUploadEnum | boolean | undefined;
  /**
   * Deprecated! Email notifications are always sent now.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  sendEmailNotification?: SendEmailNotification | undefined;
};

export type PostFoldersFolderIdSharingsRequestBody = {
  sharing: PostFoldersFolderIdSharingsSharingRequest;
};

export type PostFoldersFolderIdSharingsRequest = {
  /**
   * Hashed ID of the folder to be shared
   */
  folderId: string;
  requestBody: PostFoldersFolderIdSharingsRequestBody;
};

export type PostFoldersFolderIdSharingsShare = {
  id: number;
  name: string;
  type: string;
  email: string;
};

export type PostFoldersFolderIdSharingsFolder = {
  id: number;
  name: string;
};

/**
 * A sharing is an object that links either a contact or a contact group to a folder, including information about the contacts' permissions to that folder.
 *
 * @remarks
 */
export type SharingResponse = {
  id: number;
  isAdmin: boolean;
  canShare: boolean;
  canDownload: boolean;
  canUpload: boolean;
  share: PostFoldersFolderIdSharingsShare;
  folder: PostFoldersFolderIdSharingsFolder;
  /**
   * A cursor for stable pagination based on current `sort_by` order. You can pass this to `cursor[before]` or `cursor[after]` as a parameter to fetch the records before or after this record in the same sort order. This is only populated if records were fetched with `cursor[enabled]`, or `cursor[before]` or `cursor[after]`.
   */
  cursor?: string | null | undefined;
};

/**
 * The response includes a link for the user to access the folder.
 */
export type PostFoldersFolderIdSharingsResponseBody = {
  folder?: string | undefined;
  /**
   * A sharing is an object that links either a contact or a contact group to a folder, including information about the contacts' permissions to that folder.
   *
   * @remarks
   */
  sharing?: SharingResponse | undefined;
};

export type PostFoldersFolderIdSharingsResponse = {
  headers: { [k: string]: Array<string> };
  result: PostFoldersFolderIdSharingsResponseBody;
};

/** @internal */
export const RequirePasswordEnum$outboundSchema: z.ZodNativeEnum<
  typeof RequirePasswordEnum
> = z.nativeEnum(RequirePasswordEnum);

/** @internal */
export type RequirePassword$Outbound = string | boolean;

/** @internal */
export const RequirePassword$outboundSchema: z.ZodType<
  RequirePassword$Outbound,
  z.ZodTypeDef,
  RequirePassword
> = z.union([RequirePasswordEnum$outboundSchema, z.boolean()]);

export function requirePasswordToJSON(
  requirePassword: RequirePassword,
): string {
  return JSON.stringify(RequirePassword$outboundSchema.parse(requirePassword));
}

/** @internal */
export const CanShareEnum$outboundSchema: z.ZodNativeEnum<typeof CanShareEnum> =
  z.nativeEnum(CanShareEnum);

/** @internal */
export type CanShare$Outbound = string | boolean;

/** @internal */
export const CanShare$outboundSchema: z.ZodType<
  CanShare$Outbound,
  z.ZodTypeDef,
  CanShare
> = z.union([CanShareEnum$outboundSchema, z.boolean()]);

export function canShareToJSON(canShare: CanShare): string {
  return JSON.stringify(CanShare$outboundSchema.parse(canShare));
}

/** @internal */
export const CanDownloadEnum$outboundSchema: z.ZodNativeEnum<
  typeof CanDownloadEnum
> = z.nativeEnum(CanDownloadEnum);

/** @internal */
export type CanDownload$Outbound = string | boolean;

/** @internal */
export const CanDownload$outboundSchema: z.ZodType<
  CanDownload$Outbound,
  z.ZodTypeDef,
  CanDownload
> = z.union([CanDownloadEnum$outboundSchema, z.boolean()]);

export function canDownloadToJSON(canDownload: CanDownload): string {
  return JSON.stringify(CanDownload$outboundSchema.parse(canDownload));
}

/** @internal */
export const CanUploadEnum$outboundSchema: z.ZodNativeEnum<
  typeof CanUploadEnum
> = z.nativeEnum(CanUploadEnum);

/** @internal */
export type CanUpload$Outbound = string | boolean;

/** @internal */
export const CanUpload$outboundSchema: z.ZodType<
  CanUpload$Outbound,
  z.ZodTypeDef,
  CanUpload
> = z.union([CanUploadEnum$outboundSchema, z.boolean()]);

export function canUploadToJSON(canUpload: CanUpload): string {
  return JSON.stringify(CanUpload$outboundSchema.parse(canUpload));
}

/** @internal */
export const SendEmailNotification$outboundSchema: z.ZodNativeEnum<
  typeof SendEmailNotification
> = z.nativeEnum(SendEmailNotification);

/** @internal */
export type PostFoldersFolderIdSharingsSharingRequest$Outbound = {
  with: string;
  requirePassword?: string | boolean | undefined;
  canShare?: string | boolean | undefined;
  canDownload?: string | boolean | undefined;
  canUpload?: string | boolean | undefined;
  sendEmailNotification?: string | undefined;
};

/** @internal */
export const PostFoldersFolderIdSharingsSharingRequest$outboundSchema:
  z.ZodType<
    PostFoldersFolderIdSharingsSharingRequest$Outbound,
    z.ZodTypeDef,
    PostFoldersFolderIdSharingsSharingRequest
  > = z.object({
    with: z.string(),
    requirePassword: z.union([RequirePasswordEnum$outboundSchema, z.boolean()])
      .optional(),
    canShare: z.union([CanShareEnum$outboundSchema, z.boolean()]).optional(),
    canDownload: z.union([CanDownloadEnum$outboundSchema, z.boolean()])
      .optional(),
    canUpload: z.union([CanUploadEnum$outboundSchema, z.boolean()]).optional(),
    sendEmailNotification: SendEmailNotification$outboundSchema.optional(),
  });

export function postFoldersFolderIdSharingsSharingRequestToJSON(
  postFoldersFolderIdSharingsSharingRequest:
    PostFoldersFolderIdSharingsSharingRequest,
): string {
  return JSON.stringify(
    PostFoldersFolderIdSharingsSharingRequest$outboundSchema.parse(
      postFoldersFolderIdSharingsSharingRequest,
    ),
  );
}

/** @internal */
export type PostFoldersFolderIdSharingsRequestBody$Outbound = {
  sharing: PostFoldersFolderIdSharingsSharingRequest$Outbound;
};

/** @internal */
export const PostFoldersFolderIdSharingsRequestBody$outboundSchema: z.ZodType<
  PostFoldersFolderIdSharingsRequestBody$Outbound,
  z.ZodTypeDef,
  PostFoldersFolderIdSharingsRequestBody
> = z.object({
  sharing: z.lazy(() =>
    PostFoldersFolderIdSharingsSharingRequest$outboundSchema
  ),
});

export function postFoldersFolderIdSharingsRequestBodyToJSON(
  postFoldersFolderIdSharingsRequestBody:
    PostFoldersFolderIdSharingsRequestBody,
): string {
  return JSON.stringify(
    PostFoldersFolderIdSharingsRequestBody$outboundSchema.parse(
      postFoldersFolderIdSharingsRequestBody,
    ),
  );
}

/** @internal */
export type PostFoldersFolderIdSharingsRequest$Outbound = {
  folderId: string;
  RequestBody: PostFoldersFolderIdSharingsRequestBody$Outbound;
};

/** @internal */
export const PostFoldersFolderIdSharingsRequest$outboundSchema: z.ZodType<
  PostFoldersFolderIdSharingsRequest$Outbound,
  z.ZodTypeDef,
  PostFoldersFolderIdSharingsRequest
> = z.object({
  folderId: z.string(),
  requestBody: z.lazy(() =>
    PostFoldersFolderIdSharingsRequestBody$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

export function postFoldersFolderIdSharingsRequestToJSON(
  postFoldersFolderIdSharingsRequest: PostFoldersFolderIdSharingsRequest,
): string {
  return JSON.stringify(
    PostFoldersFolderIdSharingsRequest$outboundSchema.parse(
      postFoldersFolderIdSharingsRequest,
    ),
  );
}

/** @internal */
export const PostFoldersFolderIdSharingsShare$inboundSchema: z.ZodType<
  PostFoldersFolderIdSharingsShare,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().int(),
  name: z.string(),
  type: z.string(),
  email: z.string(),
});

export function postFoldersFolderIdSharingsShareFromJSON(
  jsonString: string,
): SafeParseResult<PostFoldersFolderIdSharingsShare, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostFoldersFolderIdSharingsShare$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostFoldersFolderIdSharingsShare' from JSON`,
  );
}

/** @internal */
export const PostFoldersFolderIdSharingsFolder$inboundSchema: z.ZodType<
  PostFoldersFolderIdSharingsFolder,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().int(),
  name: z.string(),
});

export function postFoldersFolderIdSharingsFolderFromJSON(
  jsonString: string,
): SafeParseResult<PostFoldersFolderIdSharingsFolder, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostFoldersFolderIdSharingsFolder$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostFoldersFolderIdSharingsFolder' from JSON`,
  );
}

/** @internal */
export const SharingResponse$inboundSchema: z.ZodType<
  SharingResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number().int(),
  is_admin: z.boolean(),
  can_share: z.boolean(),
  can_download: z.boolean(),
  can_upload: z.boolean(),
  share: z.lazy(() => PostFoldersFolderIdSharingsShare$inboundSchema),
  folder: z.lazy(() => PostFoldersFolderIdSharingsFolder$inboundSchema),
  cursor: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "is_admin": "isAdmin",
    "can_share": "canShare",
    "can_download": "canDownload",
    "can_upload": "canUpload",
  });
});

export function sharingResponseFromJSON(
  jsonString: string,
): SafeParseResult<SharingResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SharingResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SharingResponse' from JSON`,
  );
}

/** @internal */
export const PostFoldersFolderIdSharingsResponseBody$inboundSchema: z.ZodType<
  PostFoldersFolderIdSharingsResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  folder: z.string().optional(),
  sharing: z.lazy(() => SharingResponse$inboundSchema).optional(),
});

export function postFoldersFolderIdSharingsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  PostFoldersFolderIdSharingsResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostFoldersFolderIdSharingsResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostFoldersFolderIdSharingsResponseBody' from JSON`,
  );
}

/** @internal */
export const PostFoldersFolderIdSharingsResponse$inboundSchema: z.ZodType<
  PostFoldersFolderIdSharingsResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  Headers: z.record(z.array(z.string())).default({}),
  Result: z.lazy(() => PostFoldersFolderIdSharingsResponseBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "Headers": "headers",
    "Result": "result",
  });
});

export function postFoldersFolderIdSharingsResponseFromJSON(
  jsonString: string,
): SafeParseResult<PostFoldersFolderIdSharingsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      PostFoldersFolderIdSharingsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostFoldersFolderIdSharingsResponse' from JSON`,
  );
}
