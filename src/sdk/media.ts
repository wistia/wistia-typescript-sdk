/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { mediaArchive } from "../funcs/mediaArchive.js";
import { mediaDeleteMediasMediaHashedId } from "../funcs/mediaDeleteMediasMediaHashedId.js";
import { mediaGetMediasMediaHashedId } from "../funcs/mediaGetMediasMediaHashedId.js";
import { mediaGetMediasMediaHashedIdStats } from "../funcs/mediaGetMediasMediaHashedIdStats.js";
import { mediaList } from "../funcs/mediaList.js";
import { mediaMove } from "../funcs/mediaMove.js";
import { mediaPostMediasMediaHashedIdCopy } from "../funcs/mediaPostMediasMediaHashedIdCopy.js";
import { mediaPostMediasMediaHashedIdTranslate } from "../funcs/mediaPostMediasMediaHashedIdTranslate.js";
import { mediaPutMediasMediaHashedId } from "../funcs/mediaPutMediasMediaHashedId.js";
import { mediaPutMediasMediaHashedIdSwap } from "../funcs/mediaPutMediasMediaHashedIdSwap.js";
import { mediaRestore } from "../funcs/mediaRestore.js";
import { mediaUploadForm } from "../funcs/mediaUploadForm.js";
import { mediaUploadMultipart } from "../funcs/mediaUploadMultipart.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as models from "../models/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Media extends ClientSDK {
  /**
   * Upload or Import Media
   *
   * @remarks
   * Endpoint to upload media files from a local system or import from a web URL.
   *
   * - Use `multipart/form-data` with a `file` parameter to upload from local system
   * - Use `application/x-www-form-urlencoded` with a `url` parameter to import from web URL
   */
  async uploadMultipart(
    request?: operations.PostMultipartRequest | undefined,
    options?: RequestOptions,
  ): Promise<operations.PostMultipartResponse> {
    return unwrapAsync(mediaUploadMultipart(
      this,
      request,
      options,
    ));
  }

  /**
   * Upload or Import Media
   *
   * @remarks
   * Endpoint to upload media files from a local system or import from a web URL.
   *
   * - Use `multipart/form-data` with a `file` parameter to upload from local system
   * - Use `application/x-www-form-urlencoded` with a `url` parameter to import from web URL
   */
  async uploadForm(
    request?: operations.PostFormRequest | undefined,
    options?: RequestOptions,
  ): Promise<operations.PostFormResponse> {
    return unwrapAsync(mediaUploadForm(
      this,
      request,
      options,
    ));
  }

  /**
   * Media List
   *
   * @remarks
   * Obtain a list of all the media in your account. For accounts with more than 100 media, you’ll want to page and sort the returned list.
   *
   * ## Requires api token with one of the following permissions
   * ```
   * Read, update & delete anything
   * Read all data
   * Read all project and video data
   * ```
   */
  async list(
    request?: operations.GetMediasRequest | undefined,
    options?: RequestOptions,
  ): Promise<Array<models.MediaWithCursor>> {
    return unwrapAsync(mediaList(
      this,
      request,
      options,
    ));
  }

  /**
   * Media Show
   *
   * @remarks
   * Fetch detailed information about a media you’ve uploaded to your account using its hashed_id.
   *
   * CDN-backed medias are accessible using this url structure: https://fast.wistia.com/embed/medias/{hashed_id}.m3u8.
   * For more information, see https://docs.wistia.com/docs/asset-urls#getting-hls-assets.
   *
   * ## Requires api token with one of the following permissions
   * ```
   * Read, update & delete anything
   * Read all data
   * Read all project and video data
   * ```
   */
  async getMediasMediaHashedId(
    request: operations.GetMediasMediaHashedIdRequest,
    options?: RequestOptions,
  ): Promise<models.MediaShow> {
    return unwrapAsync(mediaGetMediasMediaHashedId(
      this,
      request,
      options,
    ));
  }

  /**
   * Media Update
   *
   * @remarks
   * Update attributes on a media.
   *
   * ## Requires api token with one of the following permissions
   * ```
   * Read, update & delete anything
   * ```
   */
  async putMediasMediaHashedId(
    request: operations.PutMediasMediaHashedIdRequest,
    options?: RequestOptions,
  ): Promise<models.Media> {
    return unwrapAsync(mediaPutMediasMediaHashedId(
      this,
      request,
      options,
    ));
  }

  /**
   * Media Delete
   *
   * @remarks
   * Delete a media.
   *
   * ## Requires api token with one of the following permissions
   * ```
   * Read, update & delete anything
   * ```
   */
  async deleteMediasMediaHashedId(
    request: operations.DeleteMediasMediaHashedIdRequest,
    options?: RequestOptions,
  ): Promise<models.MediaSchemaMedia> {
    return unwrapAsync(mediaDeleteMediasMediaHashedId(
      this,
      request,
      options,
    ));
  }

  /**
   * Media Copy
   *
   * @remarks
   * Copy a media.
   *
   * ## Requires api token with one of the following permissions
   * ```
   * Read, update & delete anything
   * ```
   */
  async postMediasMediaHashedIdCopy(
    request: operations.PostMediasMediaHashedIdCopyRequest,
    options?: RequestOptions,
  ): Promise<operations.PostMediasMediaHashedIdCopyResponse> {
    return unwrapAsync(mediaPostMediasMediaHashedIdCopy(
      this,
      request,
      options,
    ));
  }

  /**
   * Media Swap
   *
   * @remarks
   * Swap one media with another media. This operation queues a background job to replace the original media with the replacement media while preserving the original media's hashed ID and URLs.
   *
   * ## Requires api token with one of the following permissions
   * ```
   * Read, update & delete anything
   * ```
   */
  async putMediasMediaHashedIdSwap(
    request: operations.PutMediasMediaHashedIdSwapRequest,
    options?: RequestOptions,
  ): Promise<operations.PutMediasMediaHashedIdSwapResponse> {
    return unwrapAsync(mediaPutMediasMediaHashedIdSwap(
      this,
      request,
      options,
    ));
  }

  /**
   * Media Stats
   *
   * @remarks
   * Aggregated tracking statistics for a video embedded on your site.
   *
   * ## Requires api token with one of the following permissions
   * ```
   * Read, update & delete anything
   * Read all data
   * Read all project and video data
   * ```
   */
  async getMediasMediaHashedIdStats(
    request: operations.GetMediasMediaHashedIdStatsRequest,
    options?: RequestOptions,
  ): Promise<operations.GetMediasMediaHashedIdStatsResponse> {
    return unwrapAsync(mediaGetMediasMediaHashedIdStats(
      this,
      request,
      options,
    ));
  }

  /**
   * Media Translate
   *
   * @remarks
   * Translate the transcript for a media.
   *
   * ## Requires api token with one of the following permissions
   * ```
   * Read, update & delete anything
   * ```
   */
  async postMediasMediaHashedIdTranslate(
    request: operations.PostMediasMediaHashedIdTranslateRequest,
    options?: RequestOptions,
  ): Promise<operations.PostMediasMediaHashedIdTranslateResponse> {
    return unwrapAsync(mediaPostMediasMediaHashedIdTranslate(
      this,
      request,
      options,
    ));
  }

  /**
   * Medias Archive
   *
   * @remarks
   * This method accepts a list of up to 100 medias to archive per request. It processes requests asynchronously and will return a background_job_status object rather than the typical Media response object. Note that Livestream medias and Soapbox videos imported to Wistia before September 1, 2023 cannot be archived.
   *
   * ## Requires api token with one of the following permissions
   * ```
   * Read, update & delete anything
   * ```
   */
  async archive(
    request: operations.PutMediasArchiveRequest,
    options?: RequestOptions,
  ): Promise<operations.PutMediasArchiveResponse> {
    return unwrapAsync(mediaArchive(
      this,
      request,
      options,
    ));
  }

  /**
   * Media Move
   *
   * @remarks
   * Move one or many media to a different project and optionally to a specific subfolder.
   * Max 100 media per request, and max 10 requests in 5 minutes.
   * Note: this is a different rate limit than applies to the rest of the api!
   *
   * If a subfolder_id is provided, media will be moved to that subfolder. The subfolder
   * must belong to the specified project.
   *
   * Returns a Background Job as the move is async.
   *
   * ## Requires api token with one of the following permissions
   * ```
   * Read, update & delete anything
   * ```
   */
  async move(
    request: operations.PutMediasMoveRequest,
    options?: RequestOptions,
  ): Promise<operations.PutMediasMoveResponse> {
    return unwrapAsync(mediaMove(
      this,
      request,
      options,
    ));
  }

  /**
   * Media Restore
   *
   * @remarks
   * Restore archived medias to your account. This method accepts a list of up to 100 medias to restore per request. It processes requests asynchronously and will return a background_job_status object rather than the typical Media response object. Your account must have access to the Archiving feature to use this method.
   *
   * ## Requires api token with one of the following permissions
   * ```
   * Read, update & delete anything
   * ```
   */
  async restore(
    request: operations.PutMediasRestoreRequest,
    options?: RequestOptions,
  ): Promise<operations.PutMediasRestoreResponse> {
    return unwrapAsync(mediaRestore(
      this,
      request,
      options,
    ));
  }
}
