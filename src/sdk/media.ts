/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { mediaArchive } from "../funcs/mediaArchive.js";
import { mediaCopy } from "../funcs/mediaCopy.js";
import { mediaDelete } from "../funcs/mediaDelete.js";
import { mediaGet } from "../funcs/mediaGet.js";
import { mediaList } from "../funcs/mediaList.js";
import { mediaMove } from "../funcs/mediaMove.js";
import { mediaRestore } from "../funcs/mediaRestore.js";
import { mediaStats } from "../funcs/mediaStats.js";
import { mediaSwap } from "../funcs/mediaSwap.js";
import { mediaTranslate } from "../funcs/mediaTranslate.js";
import { mediaUpdate } from "../funcs/mediaUpdate.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as models from "../models/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Media extends ClientSDK {
  /**
   * Media List
   *
   * @remarks
   * Obtain a list of all the media in your account. For accounts with more than 100 media, you’ll want to page and sort the returned list.
   *
   * ## Requires api token with one of the following permissions
   * ```
   * Read, update & delete anything
   * Read all data
   * Read all project and video data
   * ```
   */
  async list(
    request?: operations.GetMediasRequest | undefined,
    options?: RequestOptions,
  ): Promise<Array<models.Media>> {
    return unwrapAsync(mediaList(
      this,
      request,
      options,
    ));
  }

  /**
   * Media Show
   *
   * @remarks
   * Fetch detailed information about a media you’ve uploaded to your account using its hashed_id.
   *
   * CDN-backed medias are accessible using this url structure: https://fast.wistia.com/embed/medias/{hashed_id}.m3u8.
   * For more information, see https://docs.wistia.com/docs/asset-urls#getting-hls-assets.
   *
   * ## Requires api token with one of the following permissions
   * ```
   * Read, update & delete anything
   * Read all data
   * Read all project and video data
   * ```
   */
  async get(
    request: operations.GetMediasMediaHashedIdRequest,
    options?: RequestOptions,
  ): Promise<models.MediaShow> {
    return unwrapAsync(mediaGet(
      this,
      request,
      options,
    ));
  }

  /**
   * Media Update
   *
   * @remarks
   * Update attributes on a media.
   *
   * ## Requires api token with one of the following permissions
   * ```
   * Read, update & delete anything
   * ```
   */
  async update(
    request: operations.PutMediasMediaHashedIdRequest,
    options?: RequestOptions,
  ): Promise<models.NoAssetMediaSchemaMedia> {
    return unwrapAsync(mediaUpdate(
      this,
      request,
      options,
    ));
  }

  /**
   * Media Delete
   *
   * @remarks
   * Delete a media.
   *
   * ## Requires api token with one of the following permissions
   * ```
   * Read, update & delete anything
   * ```
   */
  async delete(
    request: operations.DeleteMediasMediaHashedIdRequest,
    options?: RequestOptions,
  ): Promise<models.Media> {
    return unwrapAsync(mediaDelete(
      this,
      request,
      options,
    ));
  }

  /**
   * Media Copy
   *
   * @remarks
   * Copy a media.
   *
   * ## Requires api token with one of the following permissions
   * ```
   * Read, update & delete anything
   * ```
   */
  async copy(
    request: operations.PostMediasMediaHashedIdCopyRequest,
    options?: RequestOptions,
  ): Promise<operations.PostMediasMediaHashedIdCopyResponse> {
    return unwrapAsync(mediaCopy(
      this,
      request,
      options,
    ));
  }

  /**
   * Media Swap
   *
   * @remarks
   * Swap one media with another media. This operation queues a background job to replace the original media with the replacement media while preserving the original media's hashed ID and URLs.
   *
   * ## Requires api token with one of the following permissions
   * ```
   * Read, update & delete anything
   * ```
   */
  async swap(
    request: operations.PutMediasMediaHashedIdSwapRequest,
    options?: RequestOptions,
  ): Promise<operations.PutMediasMediaHashedIdSwapResponse> {
    return unwrapAsync(mediaSwap(
      this,
      request,
      options,
    ));
  }

  /**
   * Media Stats
   *
   * @remarks
   * Aggregated tracking statistics for a video embedded on your site.
   *
   * ## Requires api token with one of the following permissions
   * ```
   * Read, update & delete anything
   * Read all data
   * Read all project and video data
   * ```
   */
  async stats(
    request: operations.GetMediasMediaHashedIdStatsRequest,
    options?: RequestOptions,
  ): Promise<operations.GetMediasMediaHashedIdStatsResponse> {
    return unwrapAsync(mediaStats(
      this,
      request,
      options,
    ));
  }

  /**
   * Media Translate
   *
   * @remarks
   * Translate the transcript for a media.
   *
   * ## Requires api token with one of the following permissions
   * ```
   * Read, update & delete anything
   * ```
   */
  async translate(
    request: operations.PostMediasMediaHashedIdTranslateRequest,
    options?: RequestOptions,
  ): Promise<operations.PostMediasMediaHashedIdTranslateResponse> {
    return unwrapAsync(mediaTranslate(
      this,
      request,
      options,
    ));
  }

  /**
   * Medias Archive
   *
   * @remarks
   * This method accepts a list of up to 100 medias to archive per request. It processes requests asynchronously and will return a background_job_status object rather than the typical Media response object. Note that Livestream medias and Soapbox videos imported to Wistia before September 1, 2023 cannot be archived.
   *
   * ## Requires api token with one of the following permissions
   * ```
   * Read, update & delete anything
   * ```
   */
  async archive(
    request: operations.PutMediasArchiveRequest,
    options?: RequestOptions,
  ): Promise<operations.PutMediasArchiveResponse> {
    return unwrapAsync(mediaArchive(
      this,
      request,
      options,
    ));
  }

  /**
   * Media Move
   *
   * @remarks
   * Move one or many media to a different project and optionally to a specific subfolder.
   * Max 100 media per request, and max 10 requests in 5 minutes.
   * Note: this is a different rate limit than applies to the rest of the api!
   *
   * If a subfolder_id is provided, media will be moved to that subfolder. The subfolder
   * must belong to the specified project.
   *
   * Returns a Background Job as the move is async.
   *
   * ## Requires api token with one of the following permissions
   * ```
   * Read, update & delete anything
   * ```
   */
  async move(
    request: operations.PutMediasMoveRequest,
    options?: RequestOptions,
  ): Promise<operations.PutMediasMoveResponse> {
    return unwrapAsync(mediaMove(
      this,
      request,
      options,
    ));
  }

  /**
   * Media Restore
   *
   * @remarks
   * Restore archived medias to your account. This method accepts a list of up to 100 medias to restore per request. It processes requests asynchronously and will return a background_job_status object rather than the typical Media response object. Your account must have access to the Archiving feature to use this method.
   *
   * ## Requires api token with one of the following permissions
   * ```
   * Read, update & delete anything
   * ```
   */
  async restore(
    request: operations.PutMediasRestoreRequest,
    options?: RequestOptions,
  ): Promise<operations.PutMediasRestoreResponse> {
    return unwrapAsync(mediaRestore(
      this,
      request,
      options,
    ));
  }
}
