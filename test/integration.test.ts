import { describe, it, before, after } from 'node:test';
import assert from 'node:assert';
import { Wistia } from '../src/index.js';
import { RFCDate } from '../src/types/index.js';
import { MediaShow, Project, Tag, Subfolder, SubfolderWithMedia, AllowedDomain, LiveStreamEvent, BackgroundJobStatus, Caption } from '../src/models/index.js';
import { GetMediasMediaHashedIdCaptionsLanguageCodeResponse } from '../src/models/operations/index.js';
import { PostMultipartResponse } from "@wistia/wistia-api-client/models/operations";
import dotenv from 'dotenv';
import { exec } from 'child_process';
import { promisify } from 'util';
import { writeFile, mkdir, rm } from 'node:fs/promises';
import { openAsBlob } from 'node:fs';
import { tmpdir } from 'node:os';
import { join } from 'node:path';
import { v4 as uuidv4 } from 'uuid';
import { GetAcceptEnum } from '../src/sdk/captions.js';

const execAsync = promisify(exec);
dotenv.config();

function handleError(callback: () => Promise<void>, message: string) {
  try {
    callback();
  } catch (error: unknown) {
    if (error instanceof Error) {
      console.log(`âš ï¸  ${message}:`, error.message);
    } else {
      console.log(`âš ï¸  ${message}:`, error);
    }
  }
}

if (!process.env['WISTIA_API_KEY']) {
  console.error('âŒ Please set WISTIA_API_KEY in your .env file');
  process.exit(1);
}

const wistia = new Wistia({
  bearerAuth: process.env['WISTIA_API_KEY'],
});

async function generateTestVideo() {
  await mkdir(tempDir, { recursive: true });

  const filename = join(tempDir, `${testPrefix}.mp4`);
  await execAsync(`ffmpeg -f lavfi -t 3 -r 1 -i nullsrc=s=640x480 -vf "format=yuv444p,geq=lum='mod(floor(X/64)+floor(Y/64)+floor(T)+1,2)*255':cb=128:cr=128,format=yuv420p" -c:v libx264 -crf 28 -preset veryfast -pix_fmt yuv420p -y "${filename}"`);
  localFiles.push(filename);
  return filename;
}

function generateSRTContent(version = 1) {
  return `1
00:00:00,000 --> 00:00:01,000
Test caption version ${version}

2
00:00:01,000 --> 00:00:02,000
Generated by SDK integration test
`;
}

const testResources = {
  project: null as Project | null,
  subfolder: null as Subfolder | null,
  media: null as PostMultipartResponse | null,
  tag: null as Tag | null,
  allowedDomain: null as AllowedDomain | null,
  backgroundJobId: null as BackgroundJobStatus["id"] | null,
  liveStreamEvent: null as LiveStreamEvent | null,
  eventKey: null as string | null,
  hasCustomization: false,
  hasCaptions: false,
};

const testId = Date.now();
const testPrefix = `SDK-Integration-Test-${testId}`;

const tempDir = join(tmpdir(), `wistia-sdk-test-${testId}`);
const localFiles: string[] = []; 

async function cleanup() {
  console.log('\nðŸ§¹ Cleaning up test resources...');

  handleError(async () => {
    for (const file of localFiles) {
      await rm(file, { force: true });
    }
    await rm(tempDir, { recursive: true, force: true });
    console.log('âœ… Cleaned up local files');
  }, 'Failed to clean up local files');

  handleError(async () => {
    if (testResources.hasCaptions && testResources.media && testResources.media.hashedId) {
      await wistia.captions.delete({
        mediaHashedId: testResources.media.hashedId,
        languageCode: 'eng',
      });
      console.log('âœ… Deleted captions');
    }
  }, 'Failed to delete captions');

  handleError(async () => {
    if (testResources.hasCustomization && testResources.media && testResources.media.hashedId) {
      await wistia.customizations.delete({
        mediaId: testResources.media.hashedId,
      });
      console.log('âœ… Deleted customization');
    }
  }, 'Failed to delete customization');


  handleError(async () => {
    if (testResources.liveStreamEvent) {
      await wistia.liveStreamEvents.delete({
        id: testResources.liveStreamEvent.id,
      });
      console.log('âœ… Deleted live stream event');
    }
  }, 'Failed to delete live stream event');


  handleError(async () => {
    if (testResources.allowedDomain) {
      await wistia.allowedDomains.delete({
        domain: testResources.allowedDomain.domain,
      });
      console.log('âœ… Deleted allowed domain');
    }
  }, 'Failed to delete allowed domain');


  handleError(async () => {
    if (testResources.tag && testResources.tag.name) {
      await wistia.tags.delete({
        name: testResources.tag.name,
      });
      console.log('âœ… Deleted tag');
    }
  }, 'Failed to delete tag');

  handleError(async () => {
    if (testResources.media && testResources.media.hashedId) {
      await wistia.media.delete({
        mediaHashedId: testResources.media.hashedId,
      });
      console.log('âœ… Deleted media');
    }
  }, 'Failed to delete media');

  handleError(async () => {
    if (testResources.subfolder && testResources.project && testResources.subfolder.hashedId) {
      await wistia.subfolders.deleteSubfolder({
        projectId: testResources.project.hashedId,
        subfolderId: testResources.subfolder.hashedId,
      });
      console.log('âœ… Deleted subfolder');
    }
  }, 'Failed to delete subfolder');

  handleError(async () => {
    if (testResources.project) {
      await wistia.projects.delete({
        id: testResources.project.hashedId,
      });
      console.log('âœ… Deleted project');
    }
  }, 'Failed to delete project');

  console.log('âœ… Cleaned up test resources');
}

describe('Wistia SDK Integration Tests', () => {
  after(async () => {
    await cleanup();
  });

  describe('Account Operations', () => {
    it('should get account info', async () => {
      const account = await wistia.account.get();
      assert.ok(account, 'Account info should be returned');
      assert.ok(account.name, 'Account should have a name');
      console.log(`âœ… Account: ${account.name}`);
    });
  });

  describe('Project Operations', () => {
    it('should create a project', async () => {
      const project = await wistia.projects.create({
        name: `${testPrefix}-Project`,
        adminEmail: 'test@example.com',
        public: false,
      });

      testResources.project = project;
      assert.ok(project.hashedId, 'Project should have a hashedId');
      assert.strictEqual(project.name, `${testPrefix}-Project`);
      console.log(`âœ… Created project: ${project.name} (${project.hashedId})`);
    });

    it('should get project info', async () => {
      assert.ok(testResources.project, 'Project should exist from previous test');

      const project = await wistia.projects.get({
        id: testResources.project.hashedId,
      });

      assert.strictEqual(project.hashedId, testResources.project.hashedId);
      assert.strictEqual(project.name, `${testPrefix}-Project`);
      console.log(`âœ… Retrieved project: ${project.name} ${project.hashedId}`);
    });

    it('should update project description', async () => {
      assert.ok(testResources.project, 'Project should exist');

      const updatedProject = await wistia.projects.update({
        id: testResources.project.hashedId,
        updateProject: {
          description: `${testPrefix} - Integration test project for SDK validation`,
        },
      });

      assert.strictEqual(updatedProject.hashedId, testResources.project.hashedId);
      assert.strictEqual(updatedProject.description, `${testPrefix} - Integration test project for SDK validation`);
      console.log(`âœ… Updated project description: ${updatedProject.description}`);
    });

    it('should list projects and find our created project', async () => {
      assert.ok(testResources.project, 'Project should exist');

      const projects = await wistia.projects.list({
        sortBy: 'created',
        sortDirection: 0, // desc - newest first
        perPage: 1,
      });

      assert.ok(Array.isArray(projects), 'Should return array of projects');
      assert.strictEqual(projects.length, 1, 'Should return exactly 1 project with perPage=1');
      
      const project = projects[0];
      assert.ok(project, 'Project should exist');

      assert.strictEqual(project.hashedId, testResources.project.hashedId, 'Should return our created project as the newest');
      console.log(`âœ… Listed projects, found our project: ${project.name}`);
    });
  });

  describe('Subfolder Operations', () => {
    it('should create a subfolder in the project', async () => {
      assert.ok(testResources.project, 'Project should exist');
      console.log('Project for subfolder creation:', JSON.stringify(testResources.project, null, 2));

      const subfolder = await wistia.subfolders.create({
        projectId: testResources.project.hashedId, // Try hashedId first
        subfolderInput: {
          name: `${testPrefix}-Subfolder`,
          description: 'Test subfolder for SDK integration',
        },
      });

      testResources.subfolder = subfolder;
      assert.ok(subfolder.hashedId, 'Subfolder should have a hashedId');
      assert.strictEqual(subfolder.name, `${testPrefix}-Subfolder`);
      console.log(`âœ… Created subfolder: ${subfolder.name} (${subfolder.hashedId})`);
    });

    it('should get subfolder info', async () => {
      assert.ok(testResources.project && testResources.subfolder, 'Project and subfolder should exist');

      const subfolder = await wistia.subfolders.get({
        projectId: testResources.project.hashedId,
        subfolderId: testResources.subfolder.hashedId,
      });

      assert.strictEqual(subfolder.hashedId, testResources.subfolder.hashedId);
      assert.strictEqual(subfolder.name, `${testPrefix}-Subfolder`);
      console.log(`âœ… Retrieved subfolder: ${subfolder.name}`);
    });

    it('should list project subfolders', async () => {
      assert.ok(testResources.project && testResources.subfolder, 'Project and subfolder should exist');
      const subfolder = testResources.subfolder;

      const subfolders = await wistia.subfolders.list({
        projectId: testResources.project.hashedId,
      });

      assert.ok(Array.isArray(subfolders), 'Should return array of subfolders');
      assert.ok(subfolders.length > 0, 'Should have at least one subfolder');

      const ourSubfolder = subfolders.find(s => s.hashedId === subfolder.hashedId);
      assert.ok(ourSubfolder, 'Should find our created subfolder');
      console.log(`âœ… Listed ${subfolders.length} subfolder(s) in project`);
    });
  });

  describe('Media Operations', () => {
    let videoFile: string;

    before(async () => {
      console.log('ðŸŽ¬ Generating test video...');
      videoFile = await generateTestVideo();
      console.log(`âœ… Generated video: ${videoFile}`);
    });

    it('should upload media to project', async () => {
      assert.ok(testResources.project, 'Project should exist');
      assert.ok(videoFile, 'Video file should be generated');

      const media = await wistia.media.uploadMultipart({
        file: await openAsBlob(videoFile),
        name: `${testPrefix}-Media`,
        description: 'Test media for SDK integration',
        projectId: testResources.project.hashedId,
      });

      testResources.media = media;
      console.log('Media upload response:', JSON.stringify(media, null, 2));
      assert.ok(media.hashedId, 'Media should have a hashedId');
      console.log(`âœ… Uploaded media: ${media.name} (${media.hashedId})`);

      // Wait for media processing to complete
      console.log('â³ Waiting for media processing...');
      await new Promise(resolve => setTimeout(resolve, 30000));
    });

    it('should get media info', async () => {
      assert.ok(testResources.media, 'Media should exist');
      assert.ok(testResources.media.hashedId, 'Media should have a hashedId');

      const media = await wistia.media.get({
        mediaHashedId: testResources.media.hashedId,
      });

      assert.strictEqual(media.hashedId, testResources.media.hashedId);
      console.log(`âœ… Retrieved media: ${media.name}`);
    });

    it('should list medias and find our uploaded media', async () => {
      assert.ok(testResources.media, 'Media should exist');

      const medias = await wistia.media.list({
        sortBy: 'created',
        sortDirection: 0, // desc - newest first  
        perPage: 1,
      });

      assert.ok(Array.isArray(medias), 'Should return array of medias');
      assert.strictEqual(medias.length, 1, 'Should return exactly 1 media with perPage=1');

      const media = medias[0];
      assert.ok(media, 'Media should exist');

      assert.strictEqual(media.hashedId, testResources.media.hashedId, 'Should return our uploaded media as the newest');
      console.log(`âœ… Listed medias, found our media: ${media.name}`);
    });

    it('should move media to subfolder', async () => {
      assert.ok(testResources.media && testResources.subfolder && testResources.project, 'Media, subfolder and project should exist');
      assert.ok(testResources.media.hashedId, 'Media should have a hashedId');

      console.log(`Moving media ${testResources.media.hashedId} to subfolder ${testResources.subfolder.hashedId}`);

      await wistia.media.move({
        hashedIds: [testResources.media.hashedId],
        projectId: testResources.project.hashedId,
        subfolderId: testResources.subfolder.hashedId,
      });

      console.log(`âœ… Moved media to subfolder`);
    });

    it('should verify media is in subfolder', async () => {
      assert.ok(testResources.project && testResources.subfolder, 'Project and subfolder should exist');
      const media = testResources.media;
      assert.ok(media, 'Media should exist');

      const project = await wistia.projects.get({
        id: testResources.project.hashedId,
      });

      const subfolder = await wistia.subfolders.get({
        projectId: testResources.project.hashedId,
        subfolderId: testResources.subfolder.hashedId,
      });

      assert.ok(subfolder.medias, 'Subfolder should have medias');
      console.log(`âœ… Project media count: ${project.mediaCount}, Subfolder media count: ${subfolder.medias.length}`);

      const mediaInSubfolder = subfolder.medias?.find(m => m.hashedId === media.hashedId);
      assert.ok(mediaInSubfolder, 'Media should be in subfolder');
      console.log(`âœ… Media is in subfolder: ${mediaInSubfolder.name}`);
    });
  });

  describe('Customization Operations', () => {
    it('should create media customization', async () => {
      assert.ok(testResources.media, 'Media should exist');
      assert.ok(testResources.media.hashedId, 'Media should have a hashedId');

      const customization = await wistia.customizations.create({
        mediaId: testResources.media.hashedId,
        videoCustomization: {
          plugin: {
            postRollV1: {
              style: {
                backgroundColor: "#ff0000",
              },
              ctaType: "text",
            },
          },
          videoFoam: true,
        },
      });

      testResources.hasCustomization = true;
      assert.ok(customization, 'Customization should be created');
      console.log(`âœ… Created customization for media`);
    });

    it('should update media customization', async () => {
      assert.ok(testResources.media && testResources.hasCustomization, 'Media and customization should exist');
      assert.ok(testResources.media.hashedId, 'Media should have a hashedId');

      const customization = await wistia.customizations.update({
        mediaId: testResources.media.hashedId,
        videoCustomization: {
          plugin: {
            postRollV1: {
              style: {
                backgroundColor: "#00ff00",
              },
              ctaType: "link",
            },
          },
          videoFoam: false,
        },
      });

      assert.ok(customization, 'Customization should be updated');
      console.log(`âœ… Updated customization for media`);
    });

    it('should get media customization', async () => {
      assert.ok(testResources.media && testResources.hasCustomization, 'Media and customization should exist');
      assert.ok(testResources.media.hashedId, 'Media should have a hashedId');

      const customization = await wistia.customizations.get({
        mediaId: testResources.media.hashedId,
      });

      console.log('Customization response:', JSON.stringify(customization, null, 2));
      assert.ok(customization, 'Customization should be retrieved');

      assert.strictEqual(customization.plugin?.postRollV1?.style?.backgroundColor, "#00ff00");
      console.log(`âœ… Retrieved customization with updated background color`);
    });
  });

  describe('Caption Operations', () => {
    it('should create captions for media', async () => {
      const srtContent = generateSRTContent(1);
      const srtFilename = join(tempDir, `${testPrefix}-captions.srt`);

      await writeFile(srtFilename, srtContent);
      localFiles.push(srtFilename);

      // handleError(async () => {
        assert.ok(testResources.media, 'Media should exist');  
        assert.ok(testResources.media.hashedId, 'Media should have a hashedId');

        const captionResult = await wistia.captions.createMultipart({
          mediaHashedId: testResources.media.hashedId,
          requestBody: {
            language: 'eng',
            captionFile: await openAsBlob(srtFilename),
          },
        });

        console.log('Caption creation result (multipart):', JSON.stringify(captionResult, null, 2));
        testResources.hasCaptions = true;
        console.log(`âœ… Created captions for media using multipart`);
      // }, 'Failed to create captions for media');
    });

    it('should list captions for media', async () => {
      assert.ok(testResources.media, 'Media should exist');
      assert.ok(testResources.hasCaptions, 'Captions should exist');

      assert.ok(testResources.media.hashedId, 'Media should have a hashedId');

      const captionsList = await wistia.captions.list({
        mediaHashedId: testResources.media.hashedId,
      });

      assert.ok(Array.isArray(captionsList), 'Should return array of captions');
      assert.ok(captionsList.length > 0, 'Should have at least one caption');
      console.log(`âœ… Listed ${captionsList.length} caption(s) for media`);
    });

    it('should update captions for media', async () => {
      assert.ok(testResources.media, 'Media should exist');
      assert.ok(testResources.hasCaptions, 'Captions should exist');

      assert.ok(testResources.media.hashedId, 'Media should have a hashedId');

      const updatedSrtContent = generateSRTContent(2);
      await wistia.captions.update({
        mediaHashedId: testResources.media.hashedId,
        languageCode: 'eng',
        requestBody: {
          captionFile: updatedSrtContent,
        },
      });

      console.log(`âœ… Updated captions for media`);
    });

    it('should get captions for media', async () => { // TODO fix
      assert.ok(testResources.media, 'Media should exist');
      assert.ok(testResources.hasCaptions, 'Captions should exist');

      assert.ok(testResources.media.hashedId, 'Media should have a hashedId'); 

      console.log('Waiting for captions to be processed...');
      await new Promise(resolve => setTimeout(resolve, 30000));

      const captions: GetMediasMediaHashedIdCaptionsLanguageCodeResponse = await wistia.captions.get({
        mediaHashedId: testResources.media.hashedId,
        languageCode: 'eng',
      }, {
        acceptHeaderOverride: GetAcceptEnum.applicationJson,
      }) as Caption;

      console.log('Captions response:', JSON.stringify(captions, null, 2));

      assert.ok(captions, 'Captions should be retrieved');
      assert.ok(captions.text?.includes('version 2'), 'Captions should contain updated content');
      console.log(`âœ… Retrieved updated captions`);
    });
  });

  describe('Tag Operations', () => {
    it('should create a UUID tag', async () => {
      const tagName = `test-${uuidv4()}`;

      const tag = await wistia.tags.create({
        name: tagName,
      });

      testResources.tag = tag;
      assert.strictEqual(tag.name, tagName);
      console.log(`âœ… Created tag: ${tag.name}`);
    });

    it('should update media with tag', async () => {
      assert.ok(testResources.media && testResources.tag, 'Media and tag should exist');
      assert.ok(testResources.media.hashedId, 'Media should have a hashedId');
      assert.ok(testResources.tag.name, 'Tag should exist');

      console.log('Media for tagging:', JSON.stringify(testResources.media, null, 2));
      console.log(testResources.media.hashedId);

      await wistia.media.update({
        mediaHashedId: testResources.media.hashedId,
        requestBody: {
          tags: [testResources.tag.name],
        },
      });

      console.log(`âœ… Tagged media with: ${testResources.tag.name}`);
    });

    it('should filter media by tag', async () => {
      assert.ok(testResources.tag && testResources.media, 'Tag and media should exist');
      assert.ok(testResources.tag.name, 'Tag should exist');
      assert.ok(testResources.media.hashedId, 'Media should have a hashedId');

      const media = testResources.media;

      // Wait a moment for the tag to be indexed
      await new Promise(resolve => setTimeout(resolve, 2000));

      const medias = await wistia.media.list({
        tags: [testResources.tag.name],
      });

      assert.ok(Array.isArray(medias), 'Should return array of medias');
      assert.ok(medias.length > 0, 'Should find at least one tagged media');

      const taggedMedia = medias.find(m => m.hashedId === media.hashedId);
      assert.ok(taggedMedia, 'Should find our tagged media');
      console.log(`âœ… Found ${medias.length} media(s) with tag: ${testResources.tag.name}`);
    });
  });

  describe('Live Stream Event Operations', () => {
    it('should create a live stream event', async () => {
      // Create a future date for the live stream event
      const scheduledFor = new Date();
      scheduledFor.setDate(scheduledFor.getDate() + 7); // 7 days from now

      const liveStreamEvent = await wistia.liveStreamEvents.create({
        title: `${testPrefix} - Live Stream Event`,
        description: 'Test live stream event for SDK integration testing',
        scheduledFor: scheduledFor,
        eventDuration: 60,
      });

      testResources.liveStreamEvent = liveStreamEvent;
      assert.ok(liveStreamEvent.id, 'Live stream event should have an ID');
      assert.strictEqual(liveStreamEvent.title, `${testPrefix} - Live Stream Event`);
      console.log(`âœ… Created live stream event: ${liveStreamEvent.title} (${liveStreamEvent.id})`);
    });

    it('should list live stream events and find our created event', async () => {
      assert.ok(testResources.liveStreamEvent, 'Live stream event should exist');
      const liveStreamEvent = testResources.liveStreamEvent;

      const liveStreamEvents = await wistia.liveStreamEvents.list();

      assert.ok(Array.isArray(liveStreamEvents), 'Should return array of live stream events');

      const ourEvent = liveStreamEvents.find(event => event.id === liveStreamEvent.id);
      assert.ok(ourEvent, 'Should find our created live stream event');
      console.log(`âœ… Listed live stream events, found our event: ${ourEvent.title}`);
    });

    it('should get live stream event info', async () => {
      assert.ok(testResources.liveStreamEvent, 'Live stream event should exist');

      const liveStreamEvent = await wistia.liveStreamEvents.get({
        id: testResources.liveStreamEvent.id,
      });

      assert.strictEqual(liveStreamEvent.id, testResources.liveStreamEvent.id);
      assert.strictEqual(liveStreamEvent.title, `${testPrefix} - Live Stream Event`);
      console.log(`âœ… Retrieved live stream event: ${liveStreamEvent.title}`);
    });

    it('should update live stream event', async () => {
      assert.ok(testResources.liveStreamEvent, 'Live stream event should exist');

      // Create a new future date for the update
      const newScheduledFor = new Date();
      newScheduledFor.setDate(newScheduledFor.getDate() + 14); // 14 days from now

      const updatedEvent = await wistia.liveStreamEvents.update({
        id: testResources.liveStreamEvent.id,
        updateLiveStreamEvent: {
          liveStreamEvent: {
            title: `${testPrefix} - Updated Live Stream Event`,
            description: 'Updated description for SDK integration testing',
            scheduledFor: newScheduledFor,
            eventDuration: 90,
          },
        },
      });

      assert.strictEqual(updatedEvent.id, testResources.liveStreamEvent.id);
      assert.strictEqual(updatedEvent.title, `${testPrefix} - Updated Live Stream Event`);
      assert.strictEqual(updatedEvent.eventDuration, 90);
      console.log(`âœ… Updated live stream event: ${updatedEvent.title}`);

      // Update our reference for cleanup
      testResources.liveStreamEvent = updatedEvent;
    });
  });

  describe('Trim Operations', () => {
    it('should create a trim for media', async () => {
      assert.ok(testResources.media, 'Media should exist');
      assert.ok(testResources.media.hashedId, 'Media should have a hashedId');

      // Create a trim that cuts the video to 1 second
      // Based on Wistia API, trims might need different structure
      // An array of strings matching the format of HH:MM:SS.mmm-HH:MM:SS.mmm where HH is hours, MM is minutes, SS is seconds and mmm is milliseconds. The ranges should contain the earliest point of the trim first and the later point of the trim second.
      const trimResult = await wistia.trims.create({
        mediaHashedId: testResources.media.hashedId,
        requestBody: {
          trims: ["00:00:00.000-00:00:01.000"],
        },
      });

      console.log('Trim result:', JSON.stringify(trimResult, null, 2));

      assert.ok(trimResult.backgroundJobStatus, 'Background job status should exist');
      testResources.backgroundJobId = trimResult.backgroundJobStatus.id;
      console.log(`âœ… Created trim, background job ID: ${testResources.backgroundJobId}`);
    });
  });

  describe('Background Job Status Operations', () => {
    it('should check background job status', async () => {
      assert.ok(testResources.backgroundJobId, 'Background job ID should exist');

      // Wait a moment for the job to start processing
      await new Promise(resolve => setTimeout(resolve, 2000));

      const jobStatus = await wistia.backgroundJobStatus.get({
        backgroundJobStatusId: testResources.backgroundJobId,
      });

      console.log('Background job status:', JSON.stringify(jobStatus, null, 2));
      assert.ok(jobStatus, 'Background job status should be returned');
      console.log(`âœ… Retrieved background job status: ${jobStatus.backgroundJobStatus.status || 'unknown'}`);
    });
  });

  describe('Allowed Domain Operations', () => {
    it('should create an allowed domain', async () => {
      const testDomain = `${testId}-test.example.com`;

      const allowedDomain = await wistia.allowedDomains.create({
        domain: testDomain,
      });

      testResources.allowedDomain = allowedDomain;
      assert.ok(allowedDomain.domain, 'Allowed domain should have a domain');
      assert.strictEqual(allowedDomain.domain, testDomain);
      console.log(`âœ… Created allowed domain: ${allowedDomain.domain}`);
    });

    it('should list allowed domains', async () => {
      assert.ok(testResources.allowedDomain, 'Allowed domain should exist');
      const allowedDomain = testResources.allowedDomain;

      const allowedDomains = await wistia.allowedDomains.list({});

      assert.ok(Array.isArray(allowedDomains), 'Should return array of allowed domains');

      const ourDomain = allowedDomains.find(d => d.domain === allowedDomain.domain);
      assert.ok(ourDomain, 'Should find our created allowed domain');

      console.log(`âœ… Listed ${allowedDomains.length} allowed domain(s)`);
    });

    it('should get allowed domain info', async () => {
      assert.ok(testResources.allowedDomain, 'Allowed domain should exist');

      const domain = await wistia.allowedDomains.get({
        domain: testResources.allowedDomain.domain,
      });

      assert.strictEqual(domain.domain, testResources.allowedDomain.domain);
      console.log(`âœ… Retrieved allowed domain: ${domain.domain}`);
    });
  });

  describe('Search Operations', () => {
    it('should search for uploaded media', async () => {
      assert.ok(testResources.media, 'Media should exist');
      const media = testResources.media;
      assert.ok(media.name, 'Media should have a name');

      // Search using the media name
      const searchResults = await wistia.search.search({
        q: media.name,
      });

      console.log('Search results:', JSON.stringify(searchResults, null, 2));
      assert.ok(searchResults && searchResults.data, 'Should return search results with data property');

      // Look for our media in the results
      const allResults = [
        ...(searchResults.data.medias || []),
        ...(searchResults.data.projects || []),
      ];

      console.log(media.hashedId, media.name);

      const foundMedia = allResults.find(result =>
        result.hashedId === media.hashedId ||
        result.name === media.name
      );

      assert.ok(foundMedia, 'Media should be found in search results');
      console.log(`âœ… Found media in search results: ${foundMedia.name || foundMedia.hashedId}`);
    });

    it('should search using test prefix', async () => {
      // Search using our test prefix to find all test resources
      const searchResults = await wistia.search.search({
        q: testPrefix,
      });

      console.log(`Search results for "${testPrefix}":`, JSON.stringify(searchResults, null, 2));
      assert.ok(searchResults && searchResults.data, 'Should return search results with data property');

      const totalResults = (searchResults.data.medias?.length || 0) +
        (searchResults.data.projects?.length || 0) +
        (searchResults.data.channels?.length || 0) +
        (searchResults.data.channelEpisodes?.length || 0);

      console.log(`âœ… Search returned ${totalResults} result(s) for test prefix`);
    });
  });

  describe('Stats Operations', () => {
    it('should get account stats', async () => {
      const accountStats = await wistia.statsAccount.get();

      console.log('Account stats:', JSON.stringify(accountStats, null, 2));
      assert.ok(accountStats, 'Account stats should be returned');
      assert.ok(typeof accountStats.loadCount === 'number', 'loadCount should be a number');
      assert.ok(typeof accountStats.playCount === 'number', 'playCount should be a number');
      assert.ok(typeof accountStats.hoursWatched === 'number', 'hoursWatched should be a number');
      console.log(`âœ… Retrieved account stats: ${accountStats.loadCount} loads, ${accountStats.playCount} plays, ${accountStats.hoursWatched} hours watched`);
    });

    it('should get project stats', async () => {
      assert.ok(testResources.project, 'Project should exist');

      const projectStats = await wistia.statsProjects.get({
        projectId: testResources.project.hashedId,
      });

      console.log('Project stats:', JSON.stringify(projectStats, null, 2));
      assert.ok(projectStats, 'Project stats should be returned');
      assert.ok(typeof projectStats.loadCount === 'number', 'loadCount should be a number');
      assert.ok(typeof projectStats.playCount === 'number', 'playCount should be a number');
      assert.ok(typeof projectStats.hoursWatched === 'number', 'hoursWatched should be a number');
      console.log(`âœ… Retrieved project stats: ${projectStats.loadCount} loads, ${projectStats.playCount} plays, ${projectStats.hoursWatched} hours watched`);
    });

    it('should get media stats', async () => {
      assert.ok(testResources.media, 'Media should exist');
      assert.ok(testResources.media.hashedId, 'Media should have a hashedId');

      const mediaStats = await wistia.statsMedia.get({
        mediaId: testResources.media.hashedId,
      });

      console.log('Media stats:', JSON.stringify(mediaStats, null, 2));
      assert.ok(mediaStats, 'Media stats should be returned');
      assert.ok(typeof mediaStats.loadCount === 'number', 'loadCount should be a number');
      assert.ok(typeof mediaStats.playCount === 'number', 'playCount should be a number');
      assert.ok(typeof mediaStats.hoursWatched === 'number', 'hoursWatched should be a number');
      assert.ok(typeof mediaStats.visitors === 'number', 'visitors should be a number');
      assert.ok(typeof mediaStats.engagement === 'number', 'engagement should be a number');
      console.log(`âœ… Retrieved media stats: ${mediaStats.loadCount} loads, ${mediaStats.playCount} plays, ${mediaStats.visitors} visitors`);
    });

    it('should get media stats by date', async () => {
      assert.ok(testResources.media, 'Media should exist');
      assert.ok(testResources.media.hashedId, 'Media should have a hashedId');

      // Get stats for yesterday and today
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      const today = new Date();

      const mediaStatsByDate = await wistia.statsMedia.getByDate({
        mediaId: testResources.media.hashedId,
        startDate: new RFCDate(yesterday.toISOString().split('T')[0]),
        endDate: new RFCDate(today.toISOString().split('T')[0]),
      });

      console.log('Media stats by date:', JSON.stringify(mediaStatsByDate, null, 2));
      assert.ok(Array.isArray(mediaStatsByDate), 'Media stats by date should be an array');


      if (mediaStatsByDate.length > 0) {
        const dayStats = mediaStatsByDate[0];
        assert.ok(dayStats, 'dayStats should exist');
        assert.ok(dayStats.date, 'date should exist');
        assert.ok(typeof dayStats.loadCount === 'number', 'loadCount should be a number');
        assert.ok(typeof dayStats.playCount === 'number', 'playCount should be a number');
        assert.ok(typeof dayStats.hoursWatched === 'number', 'hoursWatched should be a number');
      }

      console.log(`âœ… Retrieved media stats by date: ${mediaStatsByDate.length} day(s) of data`);
    });

    it('should get media engagement stats', async () => {
      assert.ok(testResources.media, 'Media should exist');
      assert.ok(testResources.media.hashedId, 'Media should have a hashedId');

      const engagementStats = await wistia.statsMedia.getEngagement({
        mediaId: testResources.media.hashedId,
      });

      console.log('Media engagement stats:', JSON.stringify(engagementStats, null, 2));
      assert.ok(engagementStats, 'Engagement stats should be returned');
      assert.ok(typeof engagementStats.engagement === 'number', 'engagement should be a number');
      assert.ok(Array.isArray(engagementStats.engagementData), 'engagementData should be an array');
      assert.ok(Array.isArray(engagementStats.rewatchData), 'rewatchData should be an array');
      console.log(`âœ… Retrieved media engagement: ${engagementStats.engagement} engagement, ${engagementStats.engagementData.length} data points`);
    });

    it('should list visitors stats', async () => {
      const visitorsStats = await wistia.statsVisitors.list({
        perPage: 10,
      });

      console.log('Visitors stats:', JSON.stringify(visitorsStats, null, 2));
      assert.ok(Array.isArray(visitorsStats), 'Visitors stats should be an array');

      visitorsStats.forEach(visitor => {
        assert.ok(typeof visitor.visitorKey === 'string', 'visitorKey should be a string');
        assert.ok(visitor.createdAt, 'createdAt should exist');
        assert.ok(typeof visitor.loadCount === 'number', 'loadCount should be a number');
        assert.ok(typeof visitor.playCount === 'number', 'playCount should be a number');
        assert.ok(visitor.visitorIdentity, 'visitorIdentity should exist');
        assert.ok(visitor.visitorIdentity.email === null || typeof visitor.visitorIdentity.email === 'string', 'email should be nullable string');
      });

      console.log(`âœ… Retrieved visitors stats: ${visitorsStats.length} visitor(s)`);
    });

    it('should list events stats', async () => {
      const eventsStats = await wistia.statsEvents.list({
        perPage: 10,
      });

      console.log('Events stats:', JSON.stringify(eventsStats, null, 2));
      assert.ok(Array.isArray(eventsStats), 'Events stats should be an array');
      
      eventsStats.forEach(event => {
        assert.ok(event, 'Event should exist');
        assert.ok(event.receivedAt, 'receivedAt should exist');
        assert.ok(typeof event.eventKey === 'string', 'eventKey should be a string');
        assert.ok(typeof event.visitorKey === 'string', 'visitorKey should be a string');

        assert.ok(event.email === null || typeof event.email === 'string', 'email should be nullable string');
        assert.ok(typeof event.conversionType === 'string', 'conversionType should be a string');
      });

      console.log(`âœ… Retrieved events stats: ${eventsStats.length} event(s)`);
    });

    it('should get visitor stats by key', async () => {
      // Get a visitor key from the events list
      const eventsStats = await wistia.statsEvents.list({
        perPage: 1,
      });
      console.log('Events stats:', JSON.stringify(eventsStats, null, 2));
    });
  });
});